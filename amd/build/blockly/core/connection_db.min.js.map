{"version":3,"sources":["../../../src/blockly/core/connection_db.js"],"names":["goog","provide","require","Blockly","ConnectionDB","connections_","prototype","addConnection","connection","yPos","index","calculateIndexForYPos_","splice","findIndexOfConnection_","conn","length","bestGuess","y","pointerMin","pointerMax","pointerMid","Math","floor","removeConnection","Error","getNeighbours","maxRadius","db","currentX","x","currentY","neighbours","checkConnection_","yIndex","dx","dy","r","sqrt","push","isInYRange_","baseY","abs","searchForClosest","dxy","radius","baseX","closestIndex","bestConnection","bestRadius","temp","isConnectionAllowed","distanceFrom","init","dbList","INPUT_VALUE","OUTPUT_VALUE","NEXT_STATEMENT","PREVIOUS_STATEMENT"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A database of all the rendered connections that could\n *    possibly be connected to (i.e. not collapsed, etc).\n *    Sorted by y coordinate.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\ngoog.provide('Blockly.ConnectionDB');\n\ngoog.require('Blockly.RenderedConnection');\n\n\n/**\n * Database of connections.\n * Connections are stored in order of their vertical component.  This way\n * connections in an area may be looked up quickly using a binary search.\n * @constructor\n */\nBlockly.ConnectionDB = function() {\n  /**\n   * Array of connections sorted by y position in workspace units.\n   * @type {!Array.<!Blockly.RenderedConnection>}\n   * @private\n   */\n  this.connections_ = [];\n};\n\n/**\n * Add a connection to the database. Should not already exist in the database.\n * @param {!Blockly.RenderedConnection} connection The connection to be added.\n * @param {number} yPos The y position used to decide where to insert the\n *    connection.\n * @package\n */\nBlockly.ConnectionDB.prototype.addConnection = function(connection, yPos) {\n  var index = this.calculateIndexForYPos_(yPos);\n  this.connections_.splice(index, 0, connection);\n};\n\n/**\n * Finds the index of the given connection.\n *\n * Starts by doing a binary search to find the approximate location, then\n * linearly searches nearby for the exact connection.\n * @param {!Blockly.RenderedConnection} conn The connection to find.\n * @param {number} yPos The y position used to find the index of the connection.\n * @return {number} The index of the connection, or -1 if the connection was\n *     not found.\n * @private\n */\nBlockly.ConnectionDB.prototype.findIndexOfConnection_ = function(conn, yPos) {\n  if (!this.connections_.length) {\n    return -1;\n  }\n\n  var bestGuess = this.calculateIndexForYPos_(yPos);\n  if (bestGuess >= this.connections_.length) {\n    // Not in list\n    return -1;\n  }\n\n  yPos = conn.y;\n  // Walk forward and back on the y axis looking for the connection.\n  var pointerMin = bestGuess;\n  var pointerMax = bestGuess;\n  while (pointerMin >= 0 && this.connections_[pointerMin].y == yPos) {\n    if (this.connections_[pointerMin] == conn) {\n      return pointerMin;\n    }\n    pointerMin--;\n  }\n\n  while (pointerMax < this.connections_.length &&\n         this.connections_[pointerMax].y == yPos) {\n    if (this.connections_[pointerMax] == conn) {\n      return pointerMax;\n    }\n    pointerMax++;\n  }\n  return -1;\n};\n\n/**\n * Finds the correct index for the given y position.\n * @param {number} yPos The y position used to decide where to\n *    insert the connection.\n * @return {number} The candidate index.\n * @private\n */\nBlockly.ConnectionDB.prototype.calculateIndexForYPos_ = function(yPos) {\n  if (!this.connections_.length) {\n    return 0;\n  }\n  var pointerMin = 0;\n  var pointerMax = this.connections_.length;\n  while (pointerMin < pointerMax) {\n    var pointerMid = Math.floor((pointerMin + pointerMax) / 2);\n    if (this.connections_[pointerMid].y < yPos) {\n      pointerMin = pointerMid + 1;\n    } else if (this.connections_[pointerMid].y > yPos) {\n      pointerMax = pointerMid;\n    } else {\n      pointerMin = pointerMid;\n      break;\n    }\n  }\n  return pointerMin;\n};\n\n/**\n * Remove a connection from the database.  Must already exist in DB.\n * @param {!Blockly.RenderedConnection} connection The connection to be removed.\n * @param {number} yPos The y position used to find the index of the connection.\n * @throws {Error} If the connection cannot be found in the database.\n */\nBlockly.ConnectionDB.prototype.removeConnection = function(connection, yPos) {\n  var index = this.findIndexOfConnection_(connection, yPos);\n  if (index == -1) {\n    throw Error('Unable to find connection in connectionDB.');\n  }\n  this.connections_.splice(index, 1);\n};\n\n/**\n * Find all nearby connections to the given connection.\n * Type checking does not apply, since this function is used for bumping.\n * @param {!Blockly.RenderedConnection} connection The connection whose\n *     neighbours should be returned.\n * @param {number} maxRadius The maximum radius to another connection.\n * @return {!Array.<!Blockly.RenderedConnection>} List of connections.\n */\nBlockly.ConnectionDB.prototype.getNeighbours = function(connection, maxRadius) {\n  var db = this.connections_;\n  var currentX = connection.x;\n  var currentY = connection.y;\n\n  // Binary search to find the closest y location.\n  var pointerMin = 0;\n  var pointerMax = db.length - 2;\n  var pointerMid = pointerMax;\n  while (pointerMin < pointerMid) {\n    if (db[pointerMid].y < currentY) {\n      pointerMin = pointerMid;\n    } else {\n      pointerMax = pointerMid;\n    }\n    pointerMid = Math.floor((pointerMin + pointerMax) / 2);\n  }\n\n  var neighbours = [];\n  /**\n   * Computes if the current connection is within the allowed radius of another\n   * connection.\n   * This function is a closure and has access to outside variables.\n   * @param {number} yIndex The other connection's index in the database.\n   * @return {boolean} True if the current connection's vertical distance from\n   *     the other connection is less than the allowed radius.\n   */\n  function checkConnection_(yIndex) {\n    var dx = currentX - db[yIndex].x;\n    var dy = currentY - db[yIndex].y;\n    var r = Math.sqrt(dx * dx + dy * dy);\n    if (r <= maxRadius) {\n      neighbours.push(db[yIndex]);\n    }\n    return dy < maxRadius;\n  }\n\n  // Walk forward and back on the y axis looking for the closest x,y point.\n  pointerMin = pointerMid;\n  pointerMax = pointerMid;\n  if (db.length) {\n    while (pointerMin >= 0 && checkConnection_(pointerMin)) {\n      pointerMin--;\n    }\n    do {\n      pointerMax++;\n    } while (pointerMax < db.length && checkConnection_(pointerMax));\n  }\n\n  return neighbours;\n};\n\n/**\n * Is the candidate connection close to the reference connection.\n * Extremely fast; only looks at Y distance.\n * @param {number} index Index in database of candidate connection.\n * @param {number} baseY Reference connection's Y value.\n * @param {number} maxRadius The maximum radius to another connection.\n * @return {boolean} True if connection is in range.\n * @private\n */\nBlockly.ConnectionDB.prototype.isInYRange_ = function(index, baseY, maxRadius) {\n  return (Math.abs(this.connections_[index].y - baseY) <= maxRadius);\n};\n\n/**\n * Find the closest compatible connection to this connection.\n * @param {!Blockly.RenderedConnection} conn The connection searching for a compatible\n *     mate.\n * @param {number} maxRadius The maximum radius to another connection.\n * @param {!Blockly.utils.Coordinate} dxy Offset between this connection's\n *     location in the database and the current location (as a result of\n *     dragging).\n * @return {!{connection: Blockly.RenderedConnection, radius: number}}\n *     Contains two properties: 'connection' which is either another\n *     connection or null, and 'radius' which is the distance.\n */\nBlockly.ConnectionDB.prototype.searchForClosest = function(conn, maxRadius,\n    dxy) {\n  if (!this.connections_.length) {\n    // Don't bother.\n    return {connection: null, radius: maxRadius};\n  }\n\n  // Stash the values of x and y from before the drag.\n  var baseY = conn.y;\n  var baseX = conn.x;\n\n  conn.x = baseX + dxy.x;\n  conn.y = baseY + dxy.y;\n\n  // calculateIndexForYPos_ finds an index for insertion, which is always\n  // after any block with the same y index.  We want to search both forward\n  // and back, so search on both sides of the index.\n  var closestIndex = this.calculateIndexForYPos_(conn.y);\n\n  var bestConnection = null;\n  var bestRadius = maxRadius;\n  var temp;\n\n  // Walk forward and back on the y axis looking for the closest x,y point.\n  var pointerMin = closestIndex - 1;\n  while (pointerMin >= 0 && this.isInYRange_(pointerMin, conn.y, maxRadius)) {\n    temp = this.connections_[pointerMin];\n    if (conn.isConnectionAllowed(temp, bestRadius)) {\n      bestConnection = temp;\n      bestRadius = temp.distanceFrom(conn);\n    }\n    pointerMin--;\n  }\n\n  var pointerMax = closestIndex;\n  while (pointerMax < this.connections_.length &&\n      this.isInYRange_(pointerMax, conn.y, maxRadius)) {\n    temp = this.connections_[pointerMax];\n    if (conn.isConnectionAllowed(temp, bestRadius)) {\n      bestConnection = temp;\n      bestRadius = temp.distanceFrom(conn);\n    }\n    pointerMax++;\n  }\n\n  // Reset the values of x and y.\n  conn.x = baseX;\n  conn.y = baseY;\n\n  // If there were no valid connections, bestConnection will be null.\n  return {connection: bestConnection, radius: bestRadius};\n};\n\n/**\n * Initialize a set of connection DBs for a workspace.\n * @return {!Array.<!Blockly.ConnectionDB>} Array of databases.\n */\nBlockly.ConnectionDB.init = function() {\n  // Create four databases, one for each connection type.\n  var dbList = [];\n  dbList[Blockly.INPUT_VALUE] = new Blockly.ConnectionDB();\n  dbList[Blockly.OUTPUT_VALUE] = new Blockly.ConnectionDB();\n  dbList[Blockly.NEXT_STATEMENT] = new Blockly.ConnectionDB();\n  dbList[Blockly.PREVIOUS_STATEMENT] = new Blockly.ConnectionDB();\n  return dbList;\n};\n"],"file":"connection_db.min.js"}