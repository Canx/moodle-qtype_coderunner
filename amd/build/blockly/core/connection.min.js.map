{"version":3,"sources":["../../../src/blockly/core/connection.js"],"names":["goog","provide","require","requireType","Blockly","Connection","source","type","sourceBlock_","CAN_CONNECT","REASON_SELF_CONNECTION","REASON_WRONG_TYPE","REASON_TARGET_NULL","REASON_CHECKS_FAILED","REASON_DIFFERENT_WORKSPACES","REASON_SHADOW_PARENT","prototype","targetConnection","disposed","check_","shadowDom_","x","y","connect_","childConnection","parentConnection","parentBlock","getSourceBlock","childBlock","isConnected","disconnect","orphanBlock","targetBlock","shadowDom","getShadowDom","setShadowDom","isShadow","Xml","blockToDom","dispose","INPUT_VALUE","outputConnection","Error","connection","lastConnectionInRow","connect","NEXT_STATEMENT","previousConnection","newBlock","nextConnection","nextBlock","getNextBlock","checkType","Events","recordUndo","group","getGroup","setTimeout","workspace","getParent","setGroup","onFailedConnect","BUMP_DELAY","event","isEnabled","BlockMove","connectReciprocally_","setParent","recordNew","fire","unplug","isSuperior","canConnectWithReason","target","blockA","blockB","OPPOSITE_TYPE","checkConnection","msg","canConnectToPrevious_","candidate","draggingConnections","indexOf","isInsertionMarker","getPreviousBlock","isConnectionAllowed","canConnect","PREVIOUS_STATEMENT","OUTPUT_VALUE","isMovable","otherConnection","eventGroup","first","second","singleConnection_","block","i","thisConnection","inputList","length","startBlock","disconnectInternal_","respawnShadow_","shadow","blockShadow","domToBlock","checkType_","console","warn","onCheckChanged_","child","setCheck","check","Array","isArray","getCheck","neighbours","getParentInput","parentInput","inputs","idx","toString","input","name","toDevString"],"mappings":"AAUA,aAEAA,IAAI,CAACC,OAAL,CAAa,oBAAb,EAEAD,IAAI,CAACE,OAAL,CAAa,gBAAb,EACAF,IAAI,CAACE,OAAL,CAAa,0BAAb,EACAF,IAAI,CAACE,OAAL,CAAa,aAAb,EAEAF,IAAI,CAACG,WAAL,CAAiB,mCAAjB,EAUAC,OAAO,CAACC,UAAR,CAAqB,SAASC,CAAT,CAAiBC,CAAjB,CAAuB,CAK1C,KAAKC,YAAL,CAAoBF,CAApB,CAEA,KAAKC,IAAL,CAAYA,CACb,CARD,CAaAH,OAAO,CAACC,UAAR,CAAmBI,WAAnB,CAAiC,CAAjC,CACAL,OAAO,CAACC,UAAR,CAAmBK,sBAAnB,CAA4C,CAA5C,CACAN,OAAO,CAACC,UAAR,CAAmBM,iBAAnB,CAAuC,CAAvC,CACAP,OAAO,CAACC,UAAR,CAAmBO,kBAAnB,CAAwC,CAAxC,CACAR,OAAO,CAACC,UAAR,CAAmBQ,oBAAnB,CAA0C,CAA1C,CACAT,OAAO,CAACC,UAAR,CAAmBS,2BAAnB,CAAiD,CAAjD,CACAV,OAAO,CAACC,UAAR,CAAmBU,oBAAnB,CAA0C,CAA1C,CAMAX,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BC,gBAA7B,CAAgD,IAAhD,CAOAb,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BE,QAA7B,IAOAd,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BG,MAA7B,CAAsC,IAAtC,CAOAf,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BI,UAA7B,CAA0C,IAA1C,CAOAhB,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BK,CAA7B,CAAiC,CAAjC,CAOAjB,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BM,CAA7B,CAAiC,CAAjC,CAQAlB,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BO,QAA7B,CAAwC,SAASC,CAAT,CAA0B,IAC5DC,CAAAA,CAAgB,CAAG,IADyC,CAE5DC,CAAW,CAAGD,CAAgB,CAACE,cAAjB,EAF8C,CAG5DC,CAAU,CAAGJ,CAAe,CAACG,cAAhB,EAH+C,CAKhE,GAAIH,CAAe,CAACK,WAAhB,EAAJ,CAAmC,CACjCL,CAAe,CAACM,UAAhB,EACD,CACD,GAAIL,CAAgB,CAACI,WAAjB,EAAJ,CAAoC,IAG9BE,CAAAA,CAAW,CAAGN,CAAgB,CAACO,WAAjB,EAHgB,CAI9BC,CAAS,CAAGR,CAAgB,CAACS,YAAjB,EAJkB,CAMlCT,CAAgB,CAACU,YAAjB,CAA8B,IAA9B,EAEA,GAAIJ,CAAW,CAACK,QAAZ,EAAJ,CAA4B,CAE1BH,CAAS,CAAG7B,OAAO,CAACiC,GAAR,CAAYC,UAAZ,CAAuBP,CAAvB,CAAZ,CACAA,CAAW,CAACQ,OAAZ,KACAR,CAAW,CAAG,IACf,CALD,IAKO,IAAIN,CAAgB,CAAClB,IAAjB,EAAyBH,OAAO,CAACoC,WAArC,CAAkD,CAGvD,GAAI,CAACT,CAAW,CAACU,gBAAjB,CAAmC,CACjC,KAAMC,CAAAA,KAAK,CAAC,kDAAD,CACZ,CAID,GAAIC,CAAAA,CAAU,CAAGvC,OAAO,CAACC,UAAR,CAAmBuC,mBAAnB,CACbhB,CADa,CACDG,CADC,CAAjB,CAEA,GAAIY,CAAJ,CAAgB,CACdZ,CAAW,CAACU,gBAAZ,CAA6BI,OAA7B,CAAqCF,CAArC,EACAZ,CAAW,CAAG,IACf,CACF,CAfM,IAeA,IAAIN,CAAgB,CAAClB,IAAjB,EAAyBH,OAAO,CAAC0C,cAArC,CAAqD,CAI1D,GAAI,CAACf,CAAW,CAACgB,kBAAjB,CAAqC,CACnC,KAAML,CAAAA,KAAK,CAAC,mDAAD,CACZ,CAGD,GAAIM,CAAAA,CAAQ,CAAGpB,CAAf,CACA,MAAOoB,CAAQ,CAACC,cAAhB,CAAgC,CAC9B,GAAIC,CAAAA,CAAS,CAAGF,CAAQ,CAACG,YAAT,EAAhB,CACA,GAAID,CAAS,EAAI,CAACA,CAAS,CAACd,QAAV,EAAlB,CAAwC,CACtCY,CAAQ,CAAGE,CACZ,CAFD,IAEO,CACL,GAAInB,CAAW,CAACgB,kBAAZ,CAA+BK,SAA/B,CACAJ,CAAQ,CAACC,cADT,CAAJ,CAC8B,CAC5BD,CAAQ,CAACC,cAAT,CAAwBJ,OAAxB,CAAgCd,CAAW,CAACgB,kBAA5C,EACAhB,CAAW,CAAG,IACf,CACD,KACD,CACF,CACF,CACD,GAAIA,CAAJ,CAAiB,CAEfN,CAAgB,CAACK,UAAjB,GACA,GAAI1B,OAAO,CAACiD,MAAR,CAAeC,UAAnB,CAA+B,CAE7B,GAAIC,CAAAA,CAAK,CAAGnD,OAAO,CAACiD,MAAR,CAAeG,QAAf,EAAZ,CACAC,UAAU,CAAC,UAAW,CAEpB,GAAI1B,CAAW,CAAC2B,SAAZ,EAAyB,CAAC3B,CAAW,CAAC4B,SAAZ,EAA9B,CAAuD,CACrDvD,OAAO,CAACiD,MAAR,CAAeO,QAAf,CAAwBL,CAAxB,EACA,GAAIxB,CAAW,CAACU,gBAAhB,CAAkC,CAChCV,CAAW,CAACU,gBAAZ,CAA6BoB,eAA7B,CAA6CpC,CAA7C,CACD,CAFD,IAEO,IAAIM,CAAW,CAACgB,kBAAhB,CAAoC,CACzChB,CAAW,CAACgB,kBAAZ,CAA+Bc,eAA/B,CAA+CpC,CAA/C,CACD,CACDrB,OAAO,CAACiD,MAAR,CAAeO,QAAf,IACD,CACF,CAXS,CAWPxD,OAAO,CAAC0D,UAXD,CAYX,CACF,CAEDrC,CAAgB,CAACU,YAAjB,CAA8BF,CAA9B,CACD,CAED,GAAI8B,CAAAA,CAAJ,CACA,GAAI3D,OAAO,CAACiD,MAAR,CAAeW,SAAf,EAAJ,CAAgC,CAC9BD,CAAK,CAAG,GAAI3D,CAAAA,OAAO,CAACiD,MAAR,CAAeY,SAAnB,CAA6BrC,CAA7B,CACT,CAEDxB,OAAO,CAACC,UAAR,CAAmB6D,oBAAnB,CAAwCzC,CAAxC,CAA0DD,CAA1D,EAEAI,CAAU,CAACuC,SAAX,CAAqBzC,CAArB,EACA,GAAIqC,CAAJ,CAAW,CACTA,CAAK,CAACK,SAAN,GACAhE,OAAO,CAACiD,MAAR,CAAegB,IAAf,CAAoBN,CAApB,CACD,CACF,CAhGD,CAsGA3D,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BuB,OAA7B,CAAuC,UAAW,CAGhD,GAAI,KAAKV,WAAL,EAAJ,CAAwB,CACtB,KAAKM,YAAL,CAAkB,IAAlB,EACA,GAAIH,CAAAA,CAAW,CAAG,KAAKA,WAAL,EAAlB,CACA,GAAIA,CAAW,CAACI,QAAZ,EAAJ,CAA4B,CAE1BJ,CAAW,CAACO,OAAZ,IACD,CAHD,IAGO,CAELP,CAAW,CAACsC,MAAZ,EACD,CACF,CAED,KAAKpD,QAAL,GACD,CAhBD,CAsBAd,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BW,cAA7B,CAA8C,UAAW,CACvD,MAAO,MAAKnB,YACb,CAFD,CAQAJ,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BuD,UAA7B,CAA0C,UAAW,CACnD,MAAO,MAAKhE,IAAL,EAAaH,OAAO,CAACoC,WAArB,EACH,KAAKjC,IAAL,EAAaH,OAAO,CAAC0C,cAC1B,CAHD,CASA1C,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6Ba,WAA7B,CAA2C,UAAW,CACpD,MAAO,CAAC,CAAC,KAAKZ,gBACf,CAFD,CAWAb,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BwD,oBAA7B,CAAoD,SAASC,CAAT,CAAiB,CACnE,GAAI,CAACA,CAAL,CAAa,CACX,MAAOrE,CAAAA,OAAO,CAACC,UAAR,CAAmBO,kBAC3B,CACD,GAAI,KAAK2D,UAAL,EAAJ,CAAuB,IACjBG,CAAAA,CAAM,CAAG,KAAKlE,YADG,CAEjBmE,CAAM,CAAGF,CAAM,CAAC9C,cAAP,EACd,CAHD,IAGO,IACDgD,CAAAA,CAAM,CAAG,KAAKnE,YADb,CAEDkE,CAAM,CAAGD,CAAM,CAAC9C,cAAP,EACd,CACD,GAAI+C,CAAM,EAAIA,CAAM,EAAIC,CAAxB,CAAgC,CAC9B,MAAOvE,CAAAA,OAAO,CAACC,UAAR,CAAmBK,sBAC3B,CAFD,IAEO,IAAI+D,CAAM,CAAClE,IAAP,EAAeH,OAAO,CAACwE,aAAR,CAAsB,KAAKrE,IAA3B,CAAnB,CAAqD,CAC1D,MAAOH,CAAAA,OAAO,CAACC,UAAR,CAAmBM,iBAC3B,CAFM,IAEA,IAAI+D,CAAM,EAAIC,CAAV,EAAoBD,CAAM,CAAChB,SAAP,GAAqBiB,CAAM,CAACjB,SAApD,CAA+D,CACpE,MAAOtD,CAAAA,OAAO,CAACC,UAAR,CAAmBS,2BAC3B,CAFM,IAEA,IAAI,CAAC,KAAKsC,SAAL,CAAeqB,CAAf,CAAL,CAA6B,CAClC,MAAOrE,CAAAA,OAAO,CAACC,UAAR,CAAmBQ,oBAC3B,CAFM,IAEA,IAAI6D,CAAM,CAACtC,QAAP,IAAqB,CAACuC,CAAM,CAACvC,QAAP,EAA1B,CAA6C,CAClD,MAAOhC,CAAAA,OAAO,CAACC,UAAR,CAAmBU,oBAC3B,CACD,MAAOX,CAAAA,OAAO,CAACC,UAAR,CAAmBI,WAC3B,CAvBD,CAgCAL,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B6D,eAA7B,CAA+C,SAASJ,CAAT,CAAiB,CAC9D,OAAQ,KAAKD,oBAAL,CAA0BC,CAA1B,CAAR,EACE,IAAKrE,CAAAA,OAAO,CAACC,UAAR,CAAmBI,WAAxB,CACE,MACF,IAAKL,CAAAA,OAAO,CAACC,UAAR,CAAmBK,sBAAxB,CACE,KAAMgC,CAAAA,KAAK,CAAC,yCAAD,CAAX,CACF,IAAKtC,CAAAA,OAAO,CAACC,UAAR,CAAmBS,2BAAxB,CAEE,KAAM4B,CAAAA,KAAK,CAAC,+BAAD,CAAX,CACF,IAAKtC,CAAAA,OAAO,CAACC,UAAR,CAAmBM,iBAAxB,CACE,KAAM+B,CAAAA,KAAK,CAAC,wCAAD,CAAX,CACF,IAAKtC,CAAAA,OAAO,CAACC,UAAR,CAAmBO,kBAAxB,CACE,KAAM8B,CAAAA,KAAK,CAAC,4BAAD,CAAX,CACF,IAAKtC,CAAAA,OAAO,CAACC,UAAR,CAAmBQ,oBAAxB,CACE,GAAIiE,CAAAA,CAAG,CAAG,4BAAV,CACAA,CAAG,EAAI,KAAO,YAAP,CAAsB,KAAK3D,MAA3B,CAAoC,UAApC,CAAiDsD,CAAM,CAACtD,MAA/D,CACA,KAAMuB,CAAAA,KAAK,CAACoC,CAAD,CAAX,CACF,IAAK1E,CAAAA,OAAO,CAACC,UAAR,CAAmBU,oBAAxB,CACE,KAAM2B,CAAAA,KAAK,CAAC,wCAAD,CAAX,CACF,QACE,KAAMA,CAAAA,KAAK,CAAC,uDAAD,CAAX,CAnBJ,CAqBD,CAtBD,CAiCAtC,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B+D,qBAA7B,CAAqD,SAASC,CAAT,CAAoB,CACvE,GAAI,KAAK/D,gBAAT,CAA2B,CAGzB,QACD,CAGD,GAAsD,CAAC,CAAnD,EAAAb,OAAO,CAAC6E,mBAAR,CAA4BC,OAA5B,CAAoCF,CAApC,CAAJ,CAA0D,CACxD,QACD,CAED,GAAI,CAACA,CAAS,CAAC/D,gBAAf,CAAiC,CAC/B,QACD,CAED,GAAIe,CAAAA,CAAW,CAAGgD,CAAS,CAAChD,WAAV,EAAlB,CAEA,GAAI,CAACA,CAAW,CAACmD,iBAAZ,EAAL,CAAsC,CACpC,QACD,CAID,MAAO,CAACnD,CAAW,CAACoD,gBAAZ,EACT,CAzBD,CAgCAhF,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BqE,mBAA7B,CAAmD,SAASL,CAAT,CAAoB,CAErE,GAAIA,CAAS,CAACxE,YAAV,CAAuB2E,iBAAvB,EAAJ,CAAgD,CAC9C,QACD,CAED,GAAIG,CAAAA,CAAU,CAAG,KAAKd,oBAAL,CAA0BQ,CAA1B,CAAjB,CACA,GAAIM,CAAU,EAAIlF,OAAO,CAACC,UAAR,CAAmBI,WAArC,CAAkD,CAChD,QACD,CAED,OAAQuE,CAAS,CAACzE,IAAlB,EACE,IAAKH,CAAAA,OAAO,CAACmF,kBAAb,CACE,MAAO,MAAKR,qBAAL,CAA2BC,CAA3B,CAAP,CACF,IAAK5E,CAAAA,OAAO,CAACoF,YAAb,CAA2B,CAGzB,GAAKR,CAAS,CAACnD,WAAV,IACD,CAACmD,CAAS,CAAChD,WAAV,GAAwBmD,iBAAxB,EADD,EAEA,KAAKtD,WAAL,EAFJ,CAEwB,CACtB,QACD,CACD,KACD,CACD,IAAKzB,CAAAA,OAAO,CAACoC,WAAb,CAA0B,CAIxB,GAAIwC,CAAS,CAACnD,WAAV,IACA,CAACmD,CAAS,CAAChD,WAAV,GAAwByD,SAAxB,EADD,EAEA,CAACT,CAAS,CAAChD,WAAV,GAAwBI,QAAxB,EAFL,CAEyC,CACvC,QACD,CACD,KACD,CACD,IAAKhC,CAAAA,OAAO,CAAC0C,cAAb,CAA6B,CAK3B,GAAIkC,CAAS,CAACnD,WAAV,IACA,CAAC,KAAKrB,YAAL,CAAkByC,cADnB,EAEA,CAAC+B,CAAS,CAAChD,WAAV,GAAwBI,QAAxB,EAFD,EAGA4C,CAAS,CAAChD,WAAV,GAAwBiB,cAH5B,CAG4C,CAC1C,QACD,CACD,KACD,CACD,QACE,KAAMP,CAAAA,KAAK,CAAC,gDAAD,CAAX,CAtCJ,CA0CA,GAAsD,CAAC,CAAnD,EAAAtC,OAAO,CAAC6E,mBAAR,CAA4BC,OAA5B,CAAoCF,CAApC,CAAJ,CAA0D,CACxD,QACD,CAED,QACD,CA1DD,CAkEA5E,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B6C,eAA7B,CAA+C,UAA2B,CAEzE,CAFD,CAQAzD,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B6B,OAA7B,CAAuC,SAAS6C,CAAT,CAA0B,CAC/D,GAAI,KAAKzE,gBAAL,EAAyByE,CAA7B,CAA8C,CAE5C,MACD,CACD,KAAKb,eAAL,CAAqBa,CAArB,EACA,GAAIC,CAAAA,CAAU,CAAGvF,OAAO,CAACiD,MAAR,CAAeG,QAAf,EAAjB,CACA,GAAI,CAACmC,CAAL,CAAiB,CACfvF,OAAO,CAACiD,MAAR,CAAeO,QAAf,IACD,CAED,GAAI,KAAKW,UAAL,EAAJ,CAAuB,CAErB,KAAKhD,QAAL,CAAcmE,CAAd,CACD,CAHD,IAGO,CAELA,CAAe,CAACnE,QAAhB,CAAyB,IAAzB,CACD,CACD,GAAI,CAACoE,CAAL,CAAiB,CACfvF,OAAO,CAACiD,MAAR,CAAeO,QAAf,IACD,CACF,CArBD,CA6BAxD,OAAO,CAACC,UAAR,CAAmB6D,oBAAnB,CAA0C,SAAS0B,CAAT,CAAgBC,CAAhB,CAAwB,CAChE,GAAI,CAACD,CAAD,EAAU,CAACC,CAAf,CAAuB,CACrB,KAAMnD,CAAAA,KAAK,CAAC,kCAAD,CACZ,CACDkD,CAAK,CAAC3E,gBAAN,CAAyB4E,CAAzB,CACAA,CAAM,CAAC5E,gBAAP,CAA0B2E,CAC3B,CAND,CAiBAxF,OAAO,CAACC,UAAR,CAAmByF,iBAAnB,CAAuC,SAASC,CAAT,CAAgBhE,CAAhB,CAA6B,CAElE,OADIY,CAAAA,CAAU,CAAG,IACjB,CAASqD,CAAC,CAAG,CAAb,CACMC,CADN,CAAgBD,CAAC,CAAGD,CAAK,CAACG,SAAN,CAAgBC,MAApC,CAA4CH,CAAC,EAA7C,CAAiD,CAC3CC,CAD2C,CAC1BF,CAAK,CAACG,SAAN,CAAgBF,CAAhB,EAAmBrD,UADO,CAE/C,GAAIsD,CAAc,EAAIA,CAAc,CAAC1F,IAAf,EAAuBH,OAAO,CAACoC,WAAjD,EACAT,CAAW,CAACU,gBAAZ,CAA6BW,SAA7B,CAAuC6C,CAAvC,CADJ,CAC4D,CAC1D,GAAItD,CAAJ,CAAgB,CACd,MAAO,KACR,CACDA,CAAU,CAAGsD,CACd,CACF,CACD,MAAOtD,CAAAA,CACR,CAbD,CA2BAvC,OAAO,CAACC,UAAR,CAAmBuC,mBAAnB,CAAyC,SAASwD,CAAT,CAAqBrE,CAArB,CAAkC,IACrEiB,CAAAA,CAAQ,CAAGoD,CAD0D,CAErEzD,CAFqE,CAGzE,MAAQA,CAAU,CAAGvC,OAAO,CAACC,UAAR,CAAmByF,iBAAnB,CACc9C,CADd,CACyBjB,CADzB,CAArB,CAC6D,CAC3DiB,CAAQ,CAAGL,CAAU,CAACX,WAAX,EAAX,CACA,GAAI,CAACgB,CAAD,EAAaA,CAAQ,CAACZ,QAAT,EAAjB,CAAsC,CACpC,MAAOO,CAAAA,CACR,CACF,CACD,MAAO,KACR,CAXD,CAgBAvC,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6Bc,UAA7B,CAA0C,UAAW,CACnD,GAAI4D,CAAAA,CAAe,CAAG,KAAKzE,gBAA3B,CACA,GAAI,CAACyE,CAAL,CAAsB,CACpB,KAAMhD,CAAAA,KAAK,CAAC,kCAAD,CACZ,CACD,GAAIgD,CAAe,CAACzE,gBAAhB,EAAoC,IAAxC,CAA8C,CAC5C,KAAMyB,CAAAA,KAAK,CAAC,uDAAD,CACZ,CACD,GAAIhB,CAAAA,CAAJ,CAAiBE,CAAjB,CAA6BH,CAA7B,CACA,GAAI,KAAK8C,UAAL,EAAJ,CAAuB,CAErB7C,CAAW,CAAG,KAAKlB,YAAnB,CACAoB,CAAU,CAAG8D,CAAe,CAAC/D,cAAhB,EAAb,CACAF,CAAgB,CAAG,IACpB,CALD,IAKO,CAELC,CAAW,CAAGgE,CAAe,CAAC/D,cAAhB,EAAd,CACAC,CAAU,CAAG,KAAKpB,YAAlB,CACAiB,CAAgB,CAAGiE,CACpB,CAED,GAAIC,CAAAA,CAAU,CAAGvF,OAAO,CAACiD,MAAR,CAAeG,QAAf,EAAjB,CACA,GAAI,CAACmC,CAAL,CAAiB,CACfvF,OAAO,CAACiD,MAAR,CAAeO,QAAf,IACD,CACD,KAAKyC,mBAAL,CAAyB3E,CAAzB,CAAsCE,CAAtC,EACAH,CAAgB,CAAC6E,cAAjB,GACA,GAAI,CAACX,CAAL,CAAiB,CACfvF,OAAO,CAACiD,MAAR,CAAeO,QAAf,IACD,CACF,CA9BD,CAsCAxD,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BqF,mBAA7B,CAAmD,SAAS3E,CAAT,CAC/CE,CAD+C,CACnC,CACd,GAAImC,CAAAA,CAAJ,CACA,GAAI3D,OAAO,CAACiD,MAAR,CAAeW,SAAf,EAAJ,CAAgC,CAC9BD,CAAK,CAAG,GAAI3D,CAAAA,OAAO,CAACiD,MAAR,CAAeY,SAAnB,CAA6BrC,CAA7B,CACT,CACD,GAAI8D,CAAAA,CAAe,CAAG,KAAKzE,gBAA3B,CACAyE,CAAe,CAACzE,gBAAhB,CAAmC,IAAnC,CACA,KAAKA,gBAAL,CAAwB,IAAxB,CACAW,CAAU,CAACuC,SAAX,CAAqB,IAArB,EACA,GAAIJ,CAAJ,CAAW,CACTA,CAAK,CAACK,SAAN,GACAhE,OAAO,CAACiD,MAAR,CAAegB,IAAf,CAAoBN,CAApB,CACD,CACF,CAdD,CAoBA3D,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BsF,cAA7B,CAA8C,UAAW,IACnD5E,CAAAA,CAAW,CAAG,KAAKC,cAAL,EADqC,CAEnD4E,CAAM,CAAG,KAAKrE,YAAL,EAF0C,CAGvD,GAAIR,CAAW,CAACgC,SAAZ,EAAyB6C,CAAzB,EAAmCnG,OAAO,CAACiD,MAAR,CAAeC,UAAtD,CAAkE,CAChE,GAAIkD,CAAAA,CAAW,CACXpG,OAAO,CAACiC,GAAR,CAAYoE,UAAZ,CAAuBF,CAAvB,CAA+B7E,CAAW,CAACgC,SAA3C,CADJ,CAEA,GAAI8C,CAAW,CAAC/D,gBAAhB,CAAkC,CAChC,KAAKI,OAAL,CAAa2D,CAAW,CAAC/D,gBAAzB,CACD,CAFD,IAEO,IAAI+D,CAAW,CAACzD,kBAAhB,CAAoC,CACzC,KAAKF,OAAL,CAAa2D,CAAW,CAACzD,kBAAzB,CACD,CAFM,IAEA,CACL,KAAML,CAAAA,KAAK,CAAC,yDAAD,CACZ,CACF,CACF,CAdD,CAoBAtC,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BgB,WAA7B,CAA2C,UAAW,CACpD,GAAI,KAAKH,WAAL,EAAJ,CAAwB,CACtB,MAAO,MAAKZ,gBAAL,CAAsBU,cAAtB,EACR,CACD,MAAO,KACR,CALD,CAaAvB,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BoC,SAA7B,CAAyC,SAASsC,CAAT,CAA0B,CACjE,GAAI,CAAC,KAAKvE,MAAN,EAAgB,CAACuE,CAAe,CAACvE,MAArC,CAA6C,CAE3C,QACD,CAED,IAAK,GAAI6E,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG,KAAK7E,MAAL,CAAYgF,MAAhC,CAAwCH,CAAC,EAAzC,CAA6C,CAC3C,GAAsD,CAAC,CAAnD,EAAAN,CAAe,CAACvE,MAAhB,CAAuB+D,OAAvB,CAA+B,KAAK/D,MAAL,CAAY6E,CAAZ,CAA/B,CAAJ,CAA0D,CACxD,QACD,CACF,CAED,QACD,CAbD,CAwBA5F,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B0F,UAA7B,CAA0C,SAAShB,CAAT,CAA0B,CAClEiB,OAAO,CAACC,IAAR,oHAEA,MAAO,MAAKxD,SAAL,CAAesC,CAAf,CACR,CAJD,CAUAtF,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B6F,eAA7B,CAA+C,UAAW,CAExD,GAAI,KAAKhF,WAAL,KAAuB,CAAC,KAAKZ,gBAAN,EACvB,CAAC,KAAKmC,SAAL,CAAe,KAAKnC,gBAApB,CADD,CAAJ,CAC6C,CAC3C,GAAI6F,CAAAA,CAAK,CAAG,KAAKvC,UAAL,GAAoB,KAAKvC,WAAL,EAApB,CAAyC,KAAKxB,YAA1D,CACAsG,CAAK,CAACxC,MAAN,EACD,CACF,CAPD,CAgBAlE,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6B+F,QAA7B,CAAwC,SAASC,CAAT,CAAgB,CACtD,GAAIA,CAAJ,CAAW,CAET,GAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,CAAd,CAAL,CAA2B,CACzBA,CAAK,CAAG,CAACA,CAAD,CACT,CACD,KAAK7F,MAAL,CAAc6F,CAAd,CACA,KAAKH,eAAL,EACD,CAPD,IAOO,CACL,KAAK1F,MAAL,CAAc,IACf,CACD,MAAO,KACR,CAZD,CAoBAf,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BmG,QAA7B,CAAwC,UAAW,CACjD,MAAO,MAAKhG,MACb,CAFD,CAQAf,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BmB,YAA7B,CAA4C,SAASoE,CAAT,CAAiB,CAC3D,KAAKnF,UAAL,CAAkBmF,CACnB,CAFD,CAQAnG,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BkB,YAA7B,CAA4C,UAAW,CACrD,MAAO,MAAKd,UACb,CAFD,CAgBAhB,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BoG,UAA7B,CAA0C,UAAoB,CAC5D,MAAO,EACR,CAFD,CAUAhH,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6BqG,cAA7B,CAA8C,UAAW,CAIvD,OAHIC,CAAAA,CAAW,CAAG,IAGlB,CAFIvB,CAAK,CAAG,KAAKvF,YAEjB,CADI+G,CAAM,CAAGxB,CAAK,CAACG,SACnB,CAASsB,CAAG,CAAG,CAAf,CAAkBA,CAAG,CAAGzB,CAAK,CAACG,SAAN,CAAgBC,MAAxC,CAAgDqB,CAAG,EAAnD,CAAuD,CACrD,GAAID,CAAM,CAACC,CAAD,CAAN,CAAY7E,UAAZ,GAA2B,IAA/B,CAAqC,CACnC2E,CAAW,CAAGC,CAAM,CAACC,CAAD,CAApB,CACA,KACD,CACF,CACD,MAAOF,CAAAA,CACR,CAXD,CAkBAlH,OAAO,CAACC,UAAR,CAAmBW,SAAnB,CAA6ByG,QAA7B,CAAwC,UAAW,IAC7C3C,CAAAA,CAD6C,CAE7CiB,CAAK,CAAG,KAAKvF,YAFgC,CAGjD,GAAI,CAACuF,CAAL,CAAY,CACV,MAAO,mBACR,CAFD,IAEO,IAAIA,CAAK,CAACtD,gBAAN,EAA0B,IAA9B,CAAoC,CACzCqC,CAAG,CAAG,uBACP,CAFM,IAEA,IAAIiB,CAAK,CAAChD,kBAAN,EAA4B,IAAhC,CAAsC,CAC3C+B,CAAG,CAAG,yBACP,CAFM,IAEA,IAAIiB,CAAK,CAAC9C,cAAN,EAAwB,IAA5B,CAAkC,CACvC6B,CAAG,CAAG,qBACP,CAFM,IAEA,CAEL,OADIwC,CAAAA,CAAW,CAAG,IAClB,CAAStB,CAAC,CAAG,CAAb,CAAgB0B,CAAhB,CAAwBA,CAAK,CAAG3B,CAAK,CAACG,SAAN,CAAgBF,CAAhB,CAAhC,CAAqDA,CAAC,EAAtD,CAA0D,CACxD,GAAI0B,CAAK,CAAC/E,UAAN,EAAoB,IAAxB,CAA8B,CAC5B2E,CAAW,CAAGI,CAAd,CACA,KACD,CACF,CACD,GAAIJ,CAAJ,CAAiB,CACfxC,CAAG,CAAG,WAAYwC,CAAW,CAACK,IAAxB,CAA+B,mBACtC,CAFD,IAEO,CACLhB,OAAO,CAACC,IAAR,CAAa,mDAAb,EACA,MAAO,mBACR,CACF,CACD,MAAO9B,CAAAA,CAAG,CAAGiB,CAAK,CAAC6B,WAAN,EACd,CA3BD","sourcesContent":["/**\n * @license\n * Copyright 2011 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Components for creating connections between blocks.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\ngoog.provide('Blockly.Connection');\n\ngoog.require('Blockly.Events');\ngoog.require('Blockly.Events.BlockMove');\ngoog.require('Blockly.Xml');\n\ngoog.requireType('Blockly.IASTNodeLocationWithBlock');\n\n\n/**\n * Class for a connection between blocks.\n * @param {!Blockly.Block} source The block establishing this connection.\n * @param {number} type The type of the connection.\n * @constructor\n * @implements {Blockly.IASTNodeLocationWithBlock}\n */\nBlockly.Connection = function(source, type) {\n  /**\n   * @type {!Blockly.Block}\n   * @protected\n   */\n  this.sourceBlock_ = source;\n  /** @type {number} */\n  this.type = type;\n};\n\n/**\n * Constants for checking whether two connections are compatible.\n */\nBlockly.Connection.CAN_CONNECT = 0;\nBlockly.Connection.REASON_SELF_CONNECTION = 1;\nBlockly.Connection.REASON_WRONG_TYPE = 2;\nBlockly.Connection.REASON_TARGET_NULL = 3;\nBlockly.Connection.REASON_CHECKS_FAILED = 4;\nBlockly.Connection.REASON_DIFFERENT_WORKSPACES = 5;\nBlockly.Connection.REASON_SHADOW_PARENT = 6;\n\n/**\n * Connection this connection connects to.  Null if not connected.\n * @type {Blockly.Connection}\n */\nBlockly.Connection.prototype.targetConnection = null;\n\n/**\n * Has this connection been disposed of?\n * @type {boolean}\n * @package\n */\nBlockly.Connection.prototype.disposed = false;\n\n/**\n * List of compatible value types.  Null if all types are compatible.\n * @type {Array}\n * @private\n */\nBlockly.Connection.prototype.check_ = null;\n\n/**\n * DOM representation of a shadow block, or null if none.\n * @type {Element}\n * @private\n */\nBlockly.Connection.prototype.shadowDom_ = null;\n\n/**\n * Horizontal location of this connection.\n * @type {number}\n * @package\n */\nBlockly.Connection.prototype.x = 0;\n\n/**\n * Vertical location of this connection.\n * @type {number}\n * @package\n */\nBlockly.Connection.prototype.y = 0;\n\n/**\n * Connect two connections together.  This is the connection on the superior\n * block.\n * @param {!Blockly.Connection} childConnection Connection on inferior block.\n * @protected\n */\nBlockly.Connection.prototype.connect_ = function(childConnection) {\n  var parentConnection = this;\n  var parentBlock = parentConnection.getSourceBlock();\n  var childBlock = childConnection.getSourceBlock();\n  // Disconnect any existing parent on the child connection.\n  if (childConnection.isConnected()) {\n    childConnection.disconnect();\n  }\n  if (parentConnection.isConnected()) {\n    // Other connection is already connected to something.\n    // Disconnect it and reattach it or bump it as needed.\n    var orphanBlock = parentConnection.targetBlock();\n    var shadowDom = parentConnection.getShadowDom();\n    // Temporarily set the shadow DOM to null so it does not respawn.\n    parentConnection.setShadowDom(null);\n    // Displaced shadow blocks dissolve rather than reattaching or bumping.\n    if (orphanBlock.isShadow()) {\n      // Save the shadow block so that field values are preserved.\n      shadowDom = Blockly.Xml.blockToDom(orphanBlock);\n      orphanBlock.dispose(false);\n      orphanBlock = null;\n    } else if (parentConnection.type == Blockly.INPUT_VALUE) {\n      // Value connections.\n      // If female block is already connected, disconnect and bump the male.\n      if (!orphanBlock.outputConnection) {\n        throw Error('Orphan block does not have an output connection.');\n      }\n      // Attempt to reattach the orphan at the end of the newly inserted\n      // block.  Since this block may be a row, walk down to the end\n      // or to the first (and only) shadow block.\n      var connection = Blockly.Connection.lastConnectionInRow(\n          childBlock, orphanBlock);\n      if (connection) {\n        orphanBlock.outputConnection.connect(connection);\n        orphanBlock = null;\n      }\n    } else if (parentConnection.type == Blockly.NEXT_STATEMENT) {\n      // Statement connections.\n      // Statement blocks may be inserted into the middle of a stack.\n      // Split the stack.\n      if (!orphanBlock.previousConnection) {\n        throw Error('Orphan block does not have a previous connection.');\n      }\n      // Attempt to reattach the orphan at the bottom of the newly inserted\n      // block.  Since this block may be a stack, walk down to the end.\n      var newBlock = childBlock;\n      while (newBlock.nextConnection) {\n        var nextBlock = newBlock.getNextBlock();\n        if (nextBlock && !nextBlock.isShadow()) {\n          newBlock = nextBlock;\n        } else {\n          if (orphanBlock.previousConnection.checkType(\n              newBlock.nextConnection)) {\n            newBlock.nextConnection.connect(orphanBlock.previousConnection);\n            orphanBlock = null;\n          }\n          break;\n        }\n      }\n    }\n    if (orphanBlock) {\n      // Unable to reattach orphan.\n      parentConnection.disconnect();\n      if (Blockly.Events.recordUndo) {\n        // Bump it off to the side after a moment.\n        var group = Blockly.Events.getGroup();\n        setTimeout(function() {\n          // Verify orphan hasn't been deleted or reconnected.\n          if (orphanBlock.workspace && !orphanBlock.getParent()) {\n            Blockly.Events.setGroup(group);\n            if (orphanBlock.outputConnection) {\n              orphanBlock.outputConnection.onFailedConnect(parentConnection);\n            } else if (orphanBlock.previousConnection) {\n              orphanBlock.previousConnection.onFailedConnect(parentConnection);\n            }\n            Blockly.Events.setGroup(false);\n          }\n        }, Blockly.BUMP_DELAY);\n      }\n    }\n    // Restore the shadow DOM.\n    parentConnection.setShadowDom(shadowDom);\n  }\n\n  var event;\n  if (Blockly.Events.isEnabled()) {\n    event = new Blockly.Events.BlockMove(childBlock);\n  }\n  // Establish the connections.\n  Blockly.Connection.connectReciprocally_(parentConnection, childConnection);\n  // Demote the inferior block so that one is a child of the superior one.\n  childBlock.setParent(parentBlock);\n  if (event) {\n    event.recordNew();\n    Blockly.Events.fire(event);\n  }\n};\n\n/**\n * Dispose of this connection and deal with connected blocks.\n * @package\n */\nBlockly.Connection.prototype.dispose = function() {\n\n  // isConnected returns true for shadows and non-shadows.\n  if (this.isConnected()) {\n    this.setShadowDom(null);\n    var targetBlock = this.targetBlock();\n    if (targetBlock.isShadow()) {\n      // Destroy the attached shadow block & its children.\n      targetBlock.dispose(false);\n    } else {\n      // Disconnect the attached normal block.\n      targetBlock.unplug();\n    }\n  }\n\n  this.disposed = true;\n};\n\n/**\n * Get the source block for this connection.\n * @return {!Blockly.Block} The source block.\n */\nBlockly.Connection.prototype.getSourceBlock = function() {\n  return this.sourceBlock_;\n};\n\n/**\n * Does the connection belong to a superior block (higher in the source stack)?\n * @return {boolean} True if connection faces down or right.\n */\nBlockly.Connection.prototype.isSuperior = function() {\n  return this.type == Blockly.INPUT_VALUE ||\n      this.type == Blockly.NEXT_STATEMENT;\n};\n\n/**\n * Is the connection connected?\n * @return {boolean} True if connection is connected to another connection.\n */\nBlockly.Connection.prototype.isConnected = function() {\n  return !!this.targetConnection;\n};\n\n/**\n * Checks whether the current connection can connect with the target\n * connection.\n * @param {Blockly.Connection} target Connection to check compatibility with.\n * @return {number} Blockly.Connection.CAN_CONNECT if the connection is legal,\n *    an error code otherwise.\n */\nBlockly.Connection.prototype.canConnectWithReason = function(target) {\n  if (!target) {\n    return Blockly.Connection.REASON_TARGET_NULL;\n  }\n  if (this.isSuperior()) {\n    var blockA = this.sourceBlock_;\n    var blockB = target.getSourceBlock();\n  } else {\n    var blockB = this.sourceBlock_;\n    var blockA = target.getSourceBlock();\n  }\n  if (blockA && blockA == blockB) {\n    return Blockly.Connection.REASON_SELF_CONNECTION;\n  } else if (target.type != Blockly.OPPOSITE_TYPE[this.type]) {\n    return Blockly.Connection.REASON_WRONG_TYPE;\n  } else if (blockA && blockB && blockA.workspace !== blockB.workspace) {\n    return Blockly.Connection.REASON_DIFFERENT_WORKSPACES;\n  } else if (!this.checkType(target)) {\n    return Blockly.Connection.REASON_CHECKS_FAILED;\n  } else if (blockA.isShadow() && !blockB.isShadow()) {\n    return Blockly.Connection.REASON_SHADOW_PARENT;\n  }\n  return Blockly.Connection.CAN_CONNECT;\n};\n\n/**\n * Checks whether the current connection and target connection are compatible\n * and throws an exception if they are not.\n * @param {Blockly.Connection} target The connection to check compatibility\n *    with.\n * @package\n */\nBlockly.Connection.prototype.checkConnection = function(target) {\n  switch (this.canConnectWithReason(target)) {\n    case Blockly.Connection.CAN_CONNECT:\n      break;\n    case Blockly.Connection.REASON_SELF_CONNECTION:\n      throw Error('Attempted to connect a block to itself.');\n    case Blockly.Connection.REASON_DIFFERENT_WORKSPACES:\n      // Usually this means one block has been deleted.\n      throw Error('Blocks not on same workspace.');\n    case Blockly.Connection.REASON_WRONG_TYPE:\n      throw Error('Attempt to connect incompatible types.');\n    case Blockly.Connection.REASON_TARGET_NULL:\n      throw Error('Target connection is null.');\n    case Blockly.Connection.REASON_CHECKS_FAILED:\n      var msg = 'Connection checks failed. ';\n      msg += this + ' expected ' + this.check_ + ', found ' + target.check_;\n      throw Error(msg);\n    case Blockly.Connection.REASON_SHADOW_PARENT:\n      throw Error('Connecting non-shadow to shadow block.');\n    default:\n      throw Error('Unknown connection failure: this should never happen!');\n  }\n};\n\n/**\n * Check if the two connections can be dragged to connect to each other.\n * This is used by the connection database when searching for the closest\n * connection.\n * @param {!Blockly.Connection} candidate A nearby connection to check, which\n *     must be a previous connection.\n * @return {boolean} True if the connection is allowed, false otherwise.\n * @private\n */\nBlockly.Connection.prototype.canConnectToPrevious_ = function(candidate) {\n  if (this.targetConnection) {\n    // This connection is already occupied.\n    // A next connection will never disconnect itself mid-drag.\n    return false;\n  }\n\n  // Don't let blocks try to connect to themselves or ones they nest.\n  if (Blockly.draggingConnections.indexOf(candidate) != -1) {\n    return false;\n  }\n\n  if (!candidate.targetConnection) {\n    return true;\n  }\n\n  var targetBlock = candidate.targetBlock();\n  // If it is connected to a real block, game over.\n  if (!targetBlock.isInsertionMarker()) {\n    return false;\n  }\n  // If it's connected to an insertion marker but that insertion marker\n  // is the first block in a stack, it's still fine.  If that insertion\n  // marker is in the middle of a stack, it won't work.\n  return !targetBlock.getPreviousBlock();\n};\n\n/**\n * Check if the two connections can be dragged to connect to each other.\n * @param {!Blockly.Connection} candidate A nearby connection to check.\n * @return {boolean} True if the connection is allowed, false otherwise.\n */\nBlockly.Connection.prototype.isConnectionAllowed = function(candidate) {\n  // Don't consider insertion markers.\n  if (candidate.sourceBlock_.isInsertionMarker()) {\n    return false;\n  }\n  // Type checking.\n  var canConnect = this.canConnectWithReason(candidate);\n  if (canConnect != Blockly.Connection.CAN_CONNECT) {\n    return false;\n  }\n\n  switch (candidate.type) {\n    case Blockly.PREVIOUS_STATEMENT:\n      return this.canConnectToPrevious_(candidate);\n    case Blockly.OUTPUT_VALUE: {\n      // Don't offer to connect an already connected left (male) value plug to\n      // an available right (female) value plug.\n      if ((candidate.isConnected() &&\n          !candidate.targetBlock().isInsertionMarker()) ||\n          this.isConnected()) {\n        return false;\n      }\n      break;\n    }\n    case Blockly.INPUT_VALUE: {\n      // Offering to connect the left (male) of a value block to an already\n      // connected value pair is ok, we'll splice it in.\n      // However, don't offer to splice into an immovable block.\n      if (candidate.isConnected() &&\n          !candidate.targetBlock().isMovable() &&\n          !candidate.targetBlock().isShadow()) {\n        return false;\n      }\n      break;\n    }\n    case Blockly.NEXT_STATEMENT: {\n      // Don't let a block with no next connection bump other blocks out of the\n      // stack.  But covering up a shadow block or stack of shadow blocks is\n      // fine.  Similarly, replacing a terminal statement with another terminal\n      // statement is allowed.\n      if (candidate.isConnected() &&\n          !this.sourceBlock_.nextConnection &&\n          !candidate.targetBlock().isShadow() &&\n          candidate.targetBlock().nextConnection) {\n        return false;\n      }\n      break;\n    }\n    default:\n      throw Error('Unknown connection type in isConnectionAllowed');\n  }\n\n  // Don't let blocks try to connect to themselves or ones they nest.\n  if (Blockly.draggingConnections.indexOf(candidate) != -1) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Behavior after a connection attempt fails.\n * @param {!Blockly.Connection} _otherConnection Connection that this connection\n *     failed to connect to.\n * @package\n */\nBlockly.Connection.prototype.onFailedConnect = function(_otherConnection) {\n  // NOP\n};\n\n/**\n * Connect this connection to another connection.\n * @param {!Blockly.Connection} otherConnection Connection to connect to.\n */\nBlockly.Connection.prototype.connect = function(otherConnection) {\n  if (this.targetConnection == otherConnection) {\n    // Already connected together.  NOP.\n    return;\n  }\n  this.checkConnection(otherConnection);\n  var eventGroup = Blockly.Events.getGroup();\n  if (!eventGroup) {\n    Blockly.Events.setGroup(true);\n  }\n  // Determine which block is superior (higher in the source stack).\n  if (this.isSuperior()) {\n    // Superior block.\n    this.connect_(otherConnection);\n  } else {\n    // Inferior block.\n    otherConnection.connect_(this);\n  }\n  if (!eventGroup) {\n    Blockly.Events.setGroup(false);\n  }\n};\n\n/**\n * Update two connections to target each other.\n * @param {Blockly.Connection} first The first connection to update.\n * @param {Blockly.Connection} second The second connection to update.\n * @private\n */\nBlockly.Connection.connectReciprocally_ = function(first, second) {\n  if (!first || !second) {\n    throw Error('Cannot connect null connections.');\n  }\n  first.targetConnection = second;\n  second.targetConnection = first;\n};\n\n/**\n * Does the given block have one and only one connection point that will accept\n * an orphaned block?\n * @param {!Blockly.Block} block The superior block.\n * @param {!Blockly.Block} orphanBlock The inferior block.\n * @return {Blockly.Connection} The suitable connection point on 'block',\n *     or null.\n * @private\n */\nBlockly.Connection.singleConnection_ = function(block, orphanBlock) {\n  var connection = null;\n  for (var i = 0; i < block.inputList.length; i++) {\n    var thisConnection = block.inputList[i].connection;\n    if (thisConnection && thisConnection.type == Blockly.INPUT_VALUE &&\n        orphanBlock.outputConnection.checkType(thisConnection)) {\n      if (connection) {\n        return null;  // More than one connection.\n      }\n      connection = thisConnection;\n    }\n  }\n  return connection;\n};\n\n/**\n * Walks down a row a blocks, at each stage checking if there are any\n * connections that will accept the orphaned block.  If at any point there\n * are zero or multiple eligible connections, returns null.  Otherwise\n * returns the only input on the last block in the chain.\n * Terminates early for shadow blocks.\n * @param {!Blockly.Block} startBlock The block on which to start the search.\n * @param {!Blockly.Block} orphanBlock The block that is looking for a home.\n * @return {Blockly.Connection} The suitable connection point on the chain\n *     of blocks, or null.\n * @package\n */\nBlockly.Connection.lastConnectionInRow = function(startBlock, orphanBlock) {\n  var newBlock = startBlock;\n  var connection;\n  while ((connection = Blockly.Connection.singleConnection_(\n      /** @type {!Blockly.Block} */ (newBlock), orphanBlock))) {\n    newBlock = connection.targetBlock();\n    if (!newBlock || newBlock.isShadow()) {\n      return connection;\n    }\n  }\n  return null;\n};\n\n/**\n * Disconnect this connection.\n */\nBlockly.Connection.prototype.disconnect = function() {\n  var otherConnection = this.targetConnection;\n  if (!otherConnection) {\n    throw Error('Source connection not connected.');\n  }\n  if (otherConnection.targetConnection != this) {\n    throw Error('Target connection not connected to source connection.');\n  }\n  var parentBlock, childBlock, parentConnection;\n  if (this.isSuperior()) {\n    // Superior block.\n    parentBlock = this.sourceBlock_;\n    childBlock = otherConnection.getSourceBlock();\n    parentConnection = this;\n  } else {\n    // Inferior block.\n    parentBlock = otherConnection.getSourceBlock();\n    childBlock = this.sourceBlock_;\n    parentConnection = otherConnection;\n  }\n\n  var eventGroup = Blockly.Events.getGroup();\n  if (!eventGroup) {\n    Blockly.Events.setGroup(true);\n  }\n  this.disconnectInternal_(parentBlock, childBlock);\n  parentConnection.respawnShadow_();\n  if (!eventGroup) {\n    Blockly.Events.setGroup(false);\n  }\n};\n\n/**\n * Disconnect two blocks that are connected by this connection.\n * @param {!Blockly.Block} parentBlock The superior block.\n * @param {!Blockly.Block} childBlock The inferior block.\n * @protected\n */\nBlockly.Connection.prototype.disconnectInternal_ = function(parentBlock,\n    childBlock) {\n  var event;\n  if (Blockly.Events.isEnabled()) {\n    event = new Blockly.Events.BlockMove(childBlock);\n  }\n  var otherConnection = this.targetConnection;\n  otherConnection.targetConnection = null;\n  this.targetConnection = null;\n  childBlock.setParent(null);\n  if (event) {\n    event.recordNew();\n    Blockly.Events.fire(event);\n  }\n};\n\n/**\n * Respawn the shadow block if there was one connected to the this connection.\n * @protected\n */\nBlockly.Connection.prototype.respawnShadow_ = function() {\n  var parentBlock = this.getSourceBlock();\n  var shadow = this.getShadowDom();\n  if (parentBlock.workspace && shadow && Blockly.Events.recordUndo) {\n    var blockShadow =\n        Blockly.Xml.domToBlock(shadow, parentBlock.workspace);\n    if (blockShadow.outputConnection) {\n      this.connect(blockShadow.outputConnection);\n    } else if (blockShadow.previousConnection) {\n      this.connect(blockShadow.previousConnection);\n    } else {\n      throw Error('Child block does not have output or previous statement.');\n    }\n  }\n};\n\n/**\n * Returns the block that this connection connects to.\n * @return {Blockly.Block} The connected block or null if none is connected.\n */\nBlockly.Connection.prototype.targetBlock = function() {\n  if (this.isConnected()) {\n    return this.targetConnection.getSourceBlock();\n  }\n  return null;\n};\n\n/**\n * Is this connection compatible with another connection with respect to the\n * value type system.  E.g. square_root(\"Hello\") is not compatible.\n * @param {!Blockly.Connection} otherConnection Connection to compare against.\n * @return {boolean} True if the connections share a type.\n */\nBlockly.Connection.prototype.checkType = function(otherConnection) {\n  if (!this.check_ || !otherConnection.check_) {\n    // One or both sides are promiscuous enough that anything will fit.\n    return true;\n  }\n  // Find any intersection in the check lists.\n  for (var i = 0; i < this.check_.length; i++) {\n    if (otherConnection.check_.indexOf(this.check_[i]) != -1) {\n      return true;\n    }\n  }\n  // No intersection.\n  return false;\n};\n\n/**\n * Is this connection compatible with another connection with respect to the\n * value type system.  E.g. square_root(\"Hello\") is not compatible.\n * @param {!Blockly.Connection} otherConnection Connection to compare against.\n * @return {boolean} True if the connections share a type.\n * @private\n * @deprecated October 2019, use connection.checkType instead.\n * @suppress {unusedPrivateMembers}\n */\nBlockly.Connection.prototype.checkType_ = function(otherConnection) {\n  console.warn('Deprecated call to Blockly.Connection.prototype.checkType_, ' +\n  'use Blockly.Connection.prototype.checkType instead.');\n  return this.checkType(otherConnection);\n};\n\n/**\n * Function to be called when this connection's compatible types have changed.\n * @protected\n */\nBlockly.Connection.prototype.onCheckChanged_ = function() {\n  // The new value type may not be compatible with the existing connection.\n  if (this.isConnected() && (!this.targetConnection ||\n      !this.checkType(this.targetConnection))) {\n    var child = this.isSuperior() ? this.targetBlock() : this.sourceBlock_;\n    child.unplug();\n  }\n};\n\n/**\n * Change a connection's compatibility.\n * @param {?(string|!Array.<string>)} check Compatible value type or list of\n *     value types. Null if all types are compatible.\n * @return {!Blockly.Connection} The connection being modified\n *     (to allow chaining).\n */\nBlockly.Connection.prototype.setCheck = function(check) {\n  if (check) {\n    // Ensure that check is in an array.\n    if (!Array.isArray(check)) {\n      check = [check];\n    }\n    this.check_ = check;\n    this.onCheckChanged_();\n  } else {\n    this.check_ = null;\n  }\n  return this;\n};\n\n/**\n * Get a connection's compatibility.\n * @return {Array} List of compatible value types.\n *     Null if all types are compatible.\n * @public\n */\nBlockly.Connection.prototype.getCheck = function() {\n  return this.check_;\n};\n\n/**\n * Change a connection's shadow block.\n * @param {Element} shadow DOM representation of a block or null.\n */\nBlockly.Connection.prototype.setShadowDom = function(shadow) {\n  this.shadowDom_ = shadow;\n};\n\n/**\n * Return a connection's shadow block.\n * @return {Element} Shadow DOM representation of a block or null.\n */\nBlockly.Connection.prototype.getShadowDom = function() {\n  return this.shadowDom_;\n};\n\n/**\n * Find all nearby compatible connections to this connection.\n * Type checking does not apply, since this function is used for bumping.\n *\n * Headless configurations (the default) do not have neighboring connection,\n * and always return an empty list (the default).\n * {@link Blockly.RenderedConnection} overrides this behavior with a list\n * computed from the rendered positioning.\n * @param {number} _maxLimit The maximum radius to another connection.\n * @return {!Array.<!Blockly.Connection>} List of connections.\n * @package\n */\nBlockly.Connection.prototype.neighbours = function(_maxLimit) {\n  return [];\n};\n\n/**\n * Get the parent input of a connection.\n * @return {Blockly.Input} The input that the connection belongs to or null if\n *     no parent exists.\n * @package\n */\nBlockly.Connection.prototype.getParentInput = function() {\n  var parentInput = null;\n  var block = this.sourceBlock_;\n  var inputs = block.inputList;\n  for (var idx = 0; idx < block.inputList.length; idx++) {\n    if (inputs[idx].connection === this) {\n      parentInput = inputs[idx];\n      break;\n    }\n  }\n  return parentInput;\n};\n\n/**\n * This method returns a string describing this Connection in developer terms\n * (English only). Intended to on be used in console logs and errors.\n * @return {string} The description.\n */\nBlockly.Connection.prototype.toString = function() {\n  var msg;\n  var block = this.sourceBlock_;\n  if (!block) {\n    return 'Orphan Connection';\n  } else if (block.outputConnection == this) {\n    msg = 'Output Connection of ';\n  } else if (block.previousConnection == this) {\n    msg = 'Previous Connection of ';\n  } else if (block.nextConnection == this) {\n    msg = 'Next Connection of ';\n  } else {\n    var parentInput = null;\n    for (var i = 0, input; (input = block.inputList[i]); i++) {\n      if (input.connection == this) {\n        parentInput = input;\n        break;\n      }\n    }\n    if (parentInput) {\n      msg = 'Input \"' + parentInput.name + '\" connection on ';\n    } else {\n      console.warn('Connection not actually connected to sourceBlock_');\n      return 'Orphan Connection';\n    }\n  }\n  return msg + block.toDevString();\n};\n"],"file":"connection.min.js"}