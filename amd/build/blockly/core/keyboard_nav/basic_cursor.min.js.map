{"version":3,"sources":["../../../../src/blockly/core/keyboard_nav/basic_cursor.js"],"names":["goog","provide","require","Blockly","BasicCursor","superClass_","constructor","call","utils","object","inherits","Cursor","prototype","next","curNode","getCurNode","newNode","getNextNode_","validNode_","setCurNode","in","prev","getPreviousNode_","out","node","isValid","siblingOrParent","findSiblingOrParent_","getRightMostChild_","type","getType","ASTNode","types","OUTPUT","INPUT","FIELD","NEXT","PREVIOUS","WORKSPACE","nextNode"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a basic cursor.\n * Used to demo switching between different cursors.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n'use strict';\n\ngoog.provide('Blockly.BasicCursor');\n\ngoog.require('Blockly.ASTNode');\ngoog.require('Blockly.Cursor');\n\n\n/**\n * Class for a basic cursor.\n * This will allow the user to get to all nodes in the AST by hitting next or\n * previous.\n * @constructor\n * @extends {Blockly.Cursor}\n */\nBlockly.BasicCursor = function() {\n  Blockly.BasicCursor.superClass_.constructor.call(this);\n};\nBlockly.utils.object.inherits(Blockly.BasicCursor, Blockly.Cursor);\n\n/**\n * Find the next node in the pre order traversal.\n * @return {Blockly.ASTNode} The next node, or null if the current node is\n *     not set or there is no next value.\n * @override\n */\nBlockly.BasicCursor.prototype.next = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n  var newNode = this.getNextNode_(curNode, this.validNode_);\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * For a basic cursor we only have the ability to go next and previous, so\n * in will also allow the user to get to the next node in the pre order traversal.\n * @return {Blockly.ASTNode} The next node, or null if the current node is\n *     not set or there is no next value.\n * @override\n */\nBlockly.BasicCursor.prototype.in = function() {\n  return this.next();\n};\n\n/**\n * Find the previous node in the pre order traversal.\n * @return {Blockly.ASTNode} The previous node, or null if the current node\n *     is not set or there is no previous value.\n * @override\n */\nBlockly.BasicCursor.prototype.prev = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n  var newNode = this.getPreviousNode_(curNode, this.validNode_);\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * For a basic cursor we only have the ability to go next and previous, so\n * out will allow the user to get to the previous node in the pre order traversal.\n * @return {Blockly.ASTNode} The previous node, or null if the current node is\n *     not set or there is no previous value.\n * @override\n */\nBlockly.BasicCursor.prototype.out = function() {\n  return this.prev();\n};\n\n/**\n * Uses pre order traversal to navigate the Blockly AST. This will allow\n * a user to easily navigate the entire Blockly AST without having to go in\n * and out levels on the tree.\n * @param {Blockly.ASTNode} node The current position in the AST.\n * @param {!function(Blockly.ASTNode) : boolean} isValid A function true/false\n *     depending on whether the given node should be traversed.\n * @return {Blockly.ASTNode} The next node in the traversal.\n * @protected\n */\nBlockly.BasicCursor.prototype.getNextNode_ = function(node, isValid) {\n  if (!node) {\n    return null;\n  }\n  var newNode = node.in() || node.next();\n  if (isValid(newNode)) {\n    return newNode;\n  } else if (newNode) {\n    return this.getNextNode_(newNode, isValid);\n  }\n  var siblingOrParent = this.findSiblingOrParent_(node.out());\n  if (isValid(siblingOrParent)) {\n    return siblingOrParent;\n  } else if (siblingOrParent) {\n    return this.getNextNode_(siblingOrParent, isValid);\n  }\n  return null;\n};\n\n/**\n * Reverses the pre order traversal in order to find the previous node. This will\n * allow a user to easily navigate the entire Blockly AST without having to go in\n * and out levels on the tree.\n * @param {Blockly.ASTNode} node The current position in the AST.\n * @param {!function(Blockly.ASTNode) : boolean} isValid A function true/false\n *     depending on whether the given node should be traversed.\n * @return {Blockly.ASTNode} The previous node in the traversal or null if no\n *     previous node exists.\n * @protected\n */\nBlockly.BasicCursor.prototype.getPreviousNode_ = function(node, isValid) {\n  if (!node) {\n    return null;\n  }\n  var newNode = node.prev();\n\n  if (newNode) {\n    newNode = this.getRightMostChild_(newNode);\n  } else {\n    newNode = node.out();\n  }\n  if (isValid(newNode)) {\n    return newNode;\n  } else if (newNode) {\n    return this.getPreviousNode_(newNode, isValid);\n  }\n  return null;\n};\n\n/**\n * Decides what nodes to traverse and which ones to skip. Currently, it\n * skips output, stack and workspace nodes.\n * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n * @return {boolean} True if the node should be visited, false otherwise.\n * @protected\n */\nBlockly.BasicCursor.prototype.validNode_ = function(node) {\n  var isValid = false;\n  var type = node && node.getType();\n  if (type == Blockly.ASTNode.types.OUTPUT ||\n      type == Blockly.ASTNode.types.INPUT ||\n      type == Blockly.ASTNode.types.FIELD ||\n      type == Blockly.ASTNode.types.NEXT ||\n      type == Blockly.ASTNode.types.PREVIOUS ||\n      type == Blockly.ASTNode.types.WORKSPACE) {\n    isValid = true;\n  }\n  return isValid;\n};\n\n/**\n * From the given node find either the next valid sibling or parent.\n * @param {Blockly.ASTNode} node The current position in the AST.\n * @return {Blockly.ASTNode} The parent AST node or null if there are no\n *     valid parents.\n * @private\n */\nBlockly.BasicCursor.prototype.findSiblingOrParent_ = function(node) {\n  if (!node) {\n    return null;\n  }\n  var nextNode = node.next();\n  if (nextNode) {\n    return nextNode;\n  }\n  return this.findSiblingOrParent_(node.out());\n};\n\n\n/**\n * Get the right most child of a node.\n * @param {Blockly.ASTNode} node The node to find the right most child of.\n * @return {Blockly.ASTNode} The right most child of the given node, or the node\n *     if no child exists.\n * @private\n */\nBlockly.BasicCursor.prototype.getRightMostChild_ = function(node) {\n  if (!node.in()) {\n    return node;\n  }\n  var newNode = node.in();\n  while (newNode.next()) {\n    newNode = newNode.next();\n  }\n  return this.getRightMostChild_(newNode);\n\n};\n"],"file":"basic_cursor.min.js"}