{"version":3,"sources":["../../../../src/blockly/core/keyboard_nav/cursor.js"],"names":["goog","provide","require","requireType","Blockly","Cursor","superClass_","constructor","call","type","utils","object","inherits","Marker","prototype","next","curNode","getCurNode","newNode","getType","ASTNode","types","NEXT","BLOCK","setCurNode","in","PREVIOUS","OUTPUT","prev","out","onBlocklyAction","action","FIELD","getLocation","name","navigation","actionNames","OUT","IN"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor.\n * Used primarily for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n'use strict';\n\ngoog.provide('Blockly.Cursor');\n\ngoog.require('Blockly.Action');\ngoog.require('Blockly.ASTNode');\ngoog.require('Blockly.Marker');\ngoog.require('Blockly.navigation');\ngoog.require('Blockly.utils.object');\n\ngoog.requireType('Blockly.IBlocklyActionable');\n\n\n/**\n * Class for a cursor.\n * A cursor controls how a user navigates the Blockly AST.\n * @constructor\n * @extends {Blockly.Marker}\n * @implements {Blockly.IBlocklyActionable}\n */\nBlockly.Cursor = function() {\n  Blockly.Cursor.superClass_.constructor.call(this);\n\n  /**\n   * @override\n   */\n  this.type = 'cursor';\n};\nBlockly.utils.object.inherits(Blockly.Cursor, Blockly.Marker);\n\n/**\n * Find the next connection, field, or block.\n * @return {Blockly.ASTNode} The next element, or null if the current node is\n *     not set or there is no next value.\n * @protected\n */\nBlockly.Cursor.prototype.next = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n\n  var newNode = curNode.next();\n  while (newNode && newNode.next() &&\n    (newNode.getType() == Blockly.ASTNode.types.NEXT ||\n    newNode.getType() == Blockly.ASTNode.types.BLOCK)) {\n    newNode = newNode.next();\n  }\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * Find the in connection or field.\n * @return {Blockly.ASTNode} The in element, or null if the current node is\n *     not set or there is no in value.\n * @protected\n */\nBlockly.Cursor.prototype.in = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n  // If we are on a previous or output connection, go to the block level before\n  // performing next operation.\n  if (curNode.getType() == Blockly.ASTNode.types.PREVIOUS ||\n    curNode.getType() == Blockly.ASTNode.types.OUTPUT) {\n    curNode = curNode.next();\n  }\n  var newNode = curNode.in();\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * Find the previous connection, field, or block.\n * @return {Blockly.ASTNode} The previous element, or null if the current node\n *     is not set or there is no previous value.\n * @protected\n */\nBlockly.Cursor.prototype.prev = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n  var newNode = curNode.prev();\n\n  while (newNode && newNode.prev() &&\n    (newNode.getType() == Blockly.ASTNode.types.NEXT ||\n    newNode.getType() == Blockly.ASTNode.types.BLOCK)) {\n    newNode = newNode.prev();\n  }\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * Find the out connection, field, or block.\n * @return {Blockly.ASTNode} The out element, or null if the current node is\n *     not set or there is no out value.\n * @protected\n */\nBlockly.Cursor.prototype.out = function() {\n  var curNode = this.getCurNode();\n  if (!curNode) {\n    return null;\n  }\n  var newNode = curNode.out();\n\n  if (newNode && newNode.getType() == Blockly.ASTNode.types.BLOCK) {\n    newNode = newNode.prev() || newNode;\n  }\n\n  if (newNode) {\n    this.setCurNode(newNode);\n  }\n  return newNode;\n};\n\n/**\n * Handles the given action.\n * This is only triggered when keyboard navigation is enabled.\n * @param {!Blockly.Action} action The action to be handled.\n * @return {boolean} True if the action has been handled, false otherwise.\n */\nBlockly.Cursor.prototype.onBlocklyAction = function(action) {\n  // If we are on a field give it the option to handle the action\n  if (this.getCurNode() &&\n      this.getCurNode().getType() === Blockly.ASTNode.types.FIELD &&\n      (/** @type {!Blockly.Field} */ (this.getCurNode().getLocation()))\n          .onBlocklyAction(action)) {\n    return true;\n  }\n  switch (action.name) {\n    case Blockly.navigation.actionNames.PREVIOUS:\n      this.prev();\n      return true;\n    case Blockly.navigation.actionNames.OUT:\n      this.out();\n      return true;\n    case Blockly.navigation.actionNames.NEXT:\n      this.next();\n      return true;\n    case Blockly.navigation.actionNames.IN:\n      this.in();\n      return true;\n    default:\n      return false;\n  }\n};\n"],"file":"cursor.min.js"}