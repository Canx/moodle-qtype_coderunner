{"version":3,"sources":["../../../../../src/blockly/core/renderers/measurables/rows.js"],"names":["goog","provide","require","Blockly","blockRendering","Row","constants","type","Types","ROW","elements","height","width","minHeight","minWidth","widthWithConnectedBlocks","yPos","xPos","hasExternalInput","hasStatement","hasInlineInput","hasDummyInput","hasJaggedEdge","constants_","notchOffset","NOTCH_OFFSET_LEFT","align","prototype","measure","Error","getLastInput","i","length","elem","isInput","startsWithElemSpacer","endsWithElemSpacer","getFirstSpacer","isSpacer","getLastSpacer","TopRow","superClass_","constructor","call","TOP_ROW","capline","ascenderHeight","hasPreviousConnection","connection","utils","object","inherits","hasLeftSquareCorner","block","hasHat","hat","ADD_START_HATS","outputConnection","previousConnection","prevBlock","getPreviousBlock","getNextBlock","hasRightSquareCorner","e","isHat","Math","max","BottomRow","BOTTOM_ROW","hasNextConnection","descenderHeight","baseline","isNextConnection","SpacerRow","SPACER","BETWEEN_ROW_SPACER","followsStatement","InRowSpacer","InputRow","INPUT_ROW","connectedBlockWidths","isStatementInput","connectedBlockWidth","isExternalInput","connectionWidth"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Objects representing a single row on a rendered block and all\n * of its subcomponents.\n * @author fenichel@google.com (Rachel Fenichel)\n */\n\ngoog.provide('Blockly.blockRendering.BottomRow');\ngoog.provide('Blockly.blockRendering.InputRow');\ngoog.provide('Blockly.blockRendering.Row');\ngoog.provide('Blockly.blockRendering.SpacerRow');\ngoog.provide('Blockly.blockRendering.TopRow');\n\ngoog.require('Blockly.blockRendering.InputConnection');\ngoog.require('Blockly.blockRendering.InRowSpacer');\ngoog.require('Blockly.blockRendering.Measurable');\ngoog.require('Blockly.blockRendering.NextConnection');\ngoog.require('Blockly.blockRendering.PreviousConnection');\ngoog.require('Blockly.blockRendering.Types');\ngoog.require('Blockly.utils.object');\n\n\n/**\n * An object representing a single row on a rendered block and all of its\n * subcomponents.\n * @param {!Blockly.blockRendering.ConstantProvider} constants The rendering\n *   constants provider.\n * @package\n * @constructor\n */\nBlockly.blockRendering.Row = function(constants) {\n  /**\n   * The type of this rendering object.\n   * @package\n   * @type {number}\n   */\n  this.type = Blockly.blockRendering.Types.ROW;\n\n  /**\n   * An array of elements contained in this row.\n   * @package\n   * @type {!Array.<!Blockly.blockRendering.Measurable>}\n   */\n  this.elements = [];\n\n  /**\n   * The height of the row.\n   * @package\n   * @type {number}\n   */\n  this.height = 0;\n\n  /**\n   * The width of the row, from the left edge of the block to the right.\n   * Does not include child blocks unless they are inline.\n   * @package\n   * @type {number}\n   */\n  this.width = 0;\n\n  /**\n   * The minimum height of the row.\n   * @package\n   * @type {number}\n   */\n  this.minHeight = 0;\n\n  /**\n   * The minimum width of the row, from the left edge of the block to the right.\n   * Does not include child blocks unless they are inline.\n   * @package\n   * @type {number}\n   */\n  this.minWidth = 0;\n\n  /**\n   * The width of the row, from the left edge of the block to the edge of the\n   * block or any connected child blocks.\n   * @package\n   * @type {number}\n   */\n  this.widthWithConnectedBlocks = 0;\n\n  /**\n   * The Y position of the row relative to the origin of the block's svg group.\n   * @package\n   * @type {number}\n   */\n  this.yPos = 0;\n\n  /**\n   * The X position of the row relative to the origin of the block's svg group.\n   * @package\n   * @type {number}\n   */\n  this.xPos = 0;\n\n  /**\n   * Whether the row has any external inputs.\n   * @package\n   * @type {boolean}\n   */\n  this.hasExternalInput = false;\n\n  /**\n   * Whether the row has any statement inputs.\n   * @package\n   * @type {boolean}\n   */\n  this.hasStatement = false;\n\n  /**\n   * Whether the row has any inline inputs.\n   * @package\n   * @type {boolean}\n   */\n  this.hasInlineInput = false;\n\n  /**\n   * Whether the row has any dummy inputs.\n   * @package\n   * @type {boolean}\n   */\n  this.hasDummyInput = false;\n\n  /**\n   * Whether the row has a jagged edge.\n   * @package\n   * @type {boolean}\n   */\n  this.hasJaggedEdge = false;\n\n  /**\n   * The renderer's constant provider.\n   * @type {!Blockly.blockRendering.ConstantProvider}\n   * @protected\n   */\n  this.constants_ = constants;\n\n  this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;\n\n  /**\n   * Alignment of the row.\n   * @package\n   * @type {?number}\n   */\n  this.align = null;\n};\n\n/**\n * Inspect all subcomponents and populate all size properties on the row.\n * @package\n */\nBlockly.blockRendering.Row.prototype.measure = function() {\n  throw Error('Unexpected attempt to measure a base Row.');\n};\n\n/**\n * Get the last input on this row, if it has one.\n * @return {Blockly.blockRendering.InputConnection} The last input on the row,\n *     or null.\n * @package\n */\n// TODO: Consider moving this to InputRow, if possible.\nBlockly.blockRendering.Row.prototype.getLastInput = function() {\n  for (var i = this.elements.length - 1, elem; (elem = this.elements[i]); i--) {\n    if (Blockly.blockRendering.Types.isInput(elem)) {\n      return /** @type {Blockly.blockRendering.InputConnection} */ (elem);\n    }\n  }\n  return null;\n};\n\n/**\n * Determines whether this row should start with an element spacer.\n * @return {boolean} Whether the row should start with a spacer.\n * @package\n */\nBlockly.blockRendering.Row.prototype.startsWithElemSpacer = function() {\n  return true;\n};\n\n/**\n * Determines whether this row should end with an element spacer.\n * @return {boolean} Whether the row should end with a spacer.\n * @package\n */\nBlockly.blockRendering.Row.prototype.endsWithElemSpacer = function() {\n  return true;\n};\n\n/**\n * Convenience method to get the first spacer element on this row.\n * @return {Blockly.blockRendering.InRowSpacer} The first spacer element on\n *   this row.\n * @package\n */\nBlockly.blockRendering.Row.prototype.getFirstSpacer = function() {\n  for (var i = 0, elem; (elem = this.elements[i]); i++) {\n    if (Blockly.blockRendering.Types.isSpacer(elem)) {\n      return /** @type {Blockly.blockRendering.InRowSpacer} */ (elem);\n    }\n  }\n  return null;\n};\n\n/**\n * Convenience method to get the last spacer element on this row.\n * @return {Blockly.blockRendering.InRowSpacer} The last spacer element on\n *   this row.\n * @package\n */\nBlockly.blockRendering.Row.prototype.getLastSpacer = function() {\n  for (var i = this.elements.length - 1, elem; (elem = this.elements[i]); i--) {\n    if (Blockly.blockRendering.Types.isSpacer(elem)) {\n      return /** @type {Blockly.blockRendering.InRowSpacer} */ (elem);\n    }\n  }\n  return null;\n};\n\n/**\n * An object containing information about what elements are in the top row of a\n * block as well as sizing information for the top row.\n * Elements in a top row can consist of corners, hats, spacers, and previous\n * connections.\n * After this constructor is called, the row will contain all non-spacer\n * elements it needs.\n * @param {!Blockly.blockRendering.ConstantProvider} constants The rendering\n *   constants provider.\n * @package\n * @constructor\n * @extends {Blockly.blockRendering.Row}\n */\nBlockly.blockRendering.TopRow = function(constants) {\n  Blockly.blockRendering.TopRow.superClass_.constructor.call(this, constants);\n\n  this.type |= Blockly.blockRendering.Types.TOP_ROW;\n\n  /**\n   * The starting point for drawing the row, in the y direction.\n   * This allows us to draw hats and similar shapes that don't start at the\n   * origin. Must be non-negative (see #2820).\n   * @package\n   * @type {number}\n   */\n  this.capline = 0;\n\n  /**\n   * How much the row extends up above its capline.\n   * @type {number}\n   */\n  this.ascenderHeight = 0;\n\n  /**\n   * Whether the block has a previous connection.\n   * @package\n   * @type {boolean}\n   */\n  this.hasPreviousConnection = false;\n\n  /**\n   * The previous connection on the block, if any.\n   * @type {Blockly.blockRendering.PreviousConnection}\n   */\n  this.connection = null;\n};\nBlockly.utils.object.inherits(Blockly.blockRendering.TopRow,\n    Blockly.blockRendering.Row);\n\n/**\n * Returns whether or not the top row has a left square corner.\n * @param {!Blockly.BlockSvg} block The block whose top row this represents.\n * @return {boolean} Whether or not the top row has a left square corner.\n */\nBlockly.blockRendering.TopRow.prototype.hasLeftSquareCorner = function(block) {\n  var hasHat = (block.hat ?\n      block.hat === 'cap' : this.constants_.ADD_START_HATS) &&\n      !block.outputConnection && !block.previousConnection;\n  var prevBlock = block.getPreviousBlock();\n\n  return !!block.outputConnection ||\n      hasHat || (prevBlock ? prevBlock.getNextBlock() == block : false);\n};\n\n/**\n * Returns whether or not the top row has a right square corner.\n * @param {!Blockly.BlockSvg} _block The block whose top row this represents.\n * @return {boolean} Whether or not the top row has a right square corner.\n */\nBlockly.blockRendering.TopRow.prototype.hasRightSquareCorner = function(\n    _block) {\n  return true;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.TopRow.prototype.measure = function() {\n  var height = 0;\n  var width = 0;\n  var ascenderHeight = 0;\n  for (var e = 0, elem; (elem = this.elements[e]); e++) {\n    width += elem.width;\n    if (!(Blockly.blockRendering.Types.isSpacer(elem))) {\n      if (Blockly.blockRendering.Types.isHat(elem)) {\n        ascenderHeight = Math.max(ascenderHeight, elem.ascenderHeight);\n      } else {\n        height = Math.max(height, elem.height);\n      }\n    }\n  }\n  this.width = Math.max(this.minWidth, width);\n  this.height = Math.max(this.minHeight, height) + ascenderHeight;\n  this.ascenderHeight = ascenderHeight;\n  this.capline = this.ascenderHeight;\n  this.widthWithConnectedBlocks = this.width;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.TopRow.prototype.startsWithElemSpacer = function() {\n  return false;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.TopRow.prototype.endsWithElemSpacer = function() {\n  return false;\n};\n\n/**\n * An object containing information about what elements are in the bottom row of\n * a block as well as spacing information for the top row.\n * Elements in a bottom row can consist of corners, spacers and next\n * connections.\n * @param {!Blockly.blockRendering.ConstantProvider} constants The rendering\n *   constants provider.\n * @package\n * @constructor\n * @extends {Blockly.blockRendering.Row}\n */\nBlockly.blockRendering.BottomRow = function(constants) {\n  Blockly.blockRendering.BottomRow.superClass_.constructor.call(this,\n      constants);\n  this.type |= Blockly.blockRendering.Types.BOTTOM_ROW;\n\n  /**\n   * Whether this row has a next connection.\n   * @package\n   * @type {boolean}\n   */\n  this.hasNextConnection = false;\n\n  /**\n   * The next connection on the row, if any.\n   * @package\n   * @type {Blockly.blockRendering.NextConnection}\n   */\n  this.connection = null;\n\n  /**\n   * The amount that the bottom of the block extends below the horizontal edge,\n   * e.g. because of a next connection.  Must be non-negative (see #2820).\n   * @package\n   * @type {number}\n   */\n  this.descenderHeight = 0;\n\n  /**\n   * The Y position of the bottom edge of the block, relative to the origin\n   * of the block rendering.\n   * @type {number}\n   */\n  this.baseline = 0;\n};\nBlockly.utils.object.inherits(Blockly.blockRendering.BottomRow,\n    Blockly.blockRendering.Row);\n\n/**\n * Returns whether or not the bottom row has a left square corner.\n * @param {!Blockly.BlockSvg} block The block whose bottom row this represents.\n * @return {boolean} Whether or not the bottom row has a left square corner.\n */\nBlockly.blockRendering.BottomRow.prototype.hasLeftSquareCorner = function(\n    block) {\n  return !!block.outputConnection || !!block.getNextBlock();\n};\n\n/**\n * Returns whether or not the bottom row has a right square corner.\n * @param {!Blockly.BlockSvg} _block The block whose bottom row this represents.\n * @return {boolean} Whether or not the bottom row has a right square corner.\n */\nBlockly.blockRendering.BottomRow.prototype.hasRightSquareCorner = function(\n    _block) {\n  return true;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.BottomRow.prototype.measure = function() {\n  var height = 0;\n  var width = 0;\n  var descenderHeight = 0;\n  for (var e = 0, elem; (elem = this.elements[e]); e++) {\n    width += elem.width;\n    if (!(Blockly.blockRendering.Types.isSpacer(elem))) {\n      // Note: this assumes that next connections have *only* descenderHeight,\n      // with no height above the baseline.\n      if (Blockly.blockRendering.Types.isNextConnection(elem)) {\n        descenderHeight = Math.max(descenderHeight, elem.height);\n      } else {\n        height = Math.max(height, elem.height);\n      }\n    }\n  }\n  this.width = Math.max(this.minWidth, width);\n  this.height = Math.max(this.minHeight, height) + descenderHeight;\n  this.descenderHeight = descenderHeight;\n  this.widthWithConnectedBlocks = this.width;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.BottomRow.prototype.startsWithElemSpacer = function() {\n  return false;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.BottomRow.prototype.endsWithElemSpacer = function() {\n  return false;\n};\n\n/**\n * An object containing information about a spacer between two rows.\n * @param {!Blockly.blockRendering.ConstantProvider} constants The rendering\n *   constants provider.\n * @param {number} height The height of the spacer.\n * @param {number} width The width of the spacer.\n * @package\n * @constructor\n * @extends {Blockly.blockRendering.Row}\n */\nBlockly.blockRendering.SpacerRow = function(constants, height, width) {\n  Blockly.blockRendering.SpacerRow.superClass_.constructor.call(this,\n      constants);\n  this.type |= Blockly.blockRendering.Types.SPACER |\n      Blockly.blockRendering.Types.BETWEEN_ROW_SPACER;\n  this.width = width;\n  this.height = height;\n  this.followsStatement = false;\n  this.widthWithConnectedBlocks = 0;\n  this.elements = [\n    new Blockly.blockRendering.InRowSpacer(this.constants_, width)];\n};\nBlockly.utils.object.inherits(Blockly.blockRendering.SpacerRow,\n    Blockly.blockRendering.Row);\n\n/**\n * @override\n */\nBlockly.blockRendering.SpacerRow.prototype.measure = function() {\n  // NOP.  Width and height were set at creation.\n};\n\n/**\n * An object containing information about a row that holds one or more inputs.\n * @param {!Blockly.blockRendering.ConstantProvider} constants The rendering\n *   constants provider.\n * @package\n * @constructor\n * @extends {Blockly.blockRendering.Row}\n */\nBlockly.blockRendering.InputRow = function(constants) {\n  Blockly.blockRendering.InputRow.superClass_.constructor.call(this, constants);\n  this.type |= Blockly.blockRendering.Types.INPUT_ROW;\n\n  /**\n   * The total width of all blocks connected to this row.\n   * @type {number}\n   * @package\n   */\n  this.connectedBlockWidths = 0;\n};\nBlockly.utils.object.inherits(Blockly.blockRendering.InputRow,\n    Blockly.blockRendering.Row);\n\n/**\n * Inspect all subcomponents and populate all size properties on the row.\n * @package\n */\nBlockly.blockRendering.InputRow.prototype.measure = function() {\n  this.width = this.minWidth;\n  this.height = this.minHeight;\n  var connectedBlockWidths = 0;\n  for (var e = 0, elem; (elem = this.elements[e]); e++) {\n    this.width += elem.width;\n    if (Blockly.blockRendering.Types.isInput(elem)) {\n      if (Blockly.blockRendering.Types.isStatementInput(elem)) {\n        connectedBlockWidths += elem.connectedBlockWidth;\n      } else if (Blockly.blockRendering.Types.isExternalInput(elem) &&\n          elem.connectedBlockWidth != 0) {\n        connectedBlockWidths += (elem.connectedBlockWidth -\n          elem.connectionWidth);\n      }\n    }\n    if (!(Blockly.blockRendering.Types.isSpacer(elem))) {\n      this.height = Math.max(this.height, elem.height);\n    }\n  }\n  this.connectedBlockWidths = connectedBlockWidths;\n  this.widthWithConnectedBlocks = this.width + connectedBlockWidths;\n};\n\n/**\n * @override\n */\nBlockly.blockRendering.InputRow.prototype.endsWithElemSpacer = function() {\n  return !this.hasExternalInput && !this.hasStatement;\n};\n"],"file":"rows.min.js"}