{"version":3,"sources":["../../../src/blockly/core/insertion_marker_manager.js"],"names":["goog","provide","require","Blockly","InsertionMarkerManager","block","selected","topBlock_","workspace_","workspace","lastOnStack_","lastMarker_","firstMarker_","createMarkerBlock_","closestConnection_","localConnection_","wouldDeleteBlock_","markerConnection_","highlightedBlock_","fadedBlock_","availableConnections_","initAvailableConnections_","PREVIEW_TYPE","INSERTION_MARKER","INPUT_OUTLINE","REPLACEMENT_FADE","prototype","dispose","length","Events","disable","enable","updateAvailableConnections","wouldDeleteBlock","wouldConnectBlock","applyConnections","hidePreview_","connect","rendered","inferiorConnection","isSuperior","blockAnimations","connectionUiEffect","getSourceBlock","rootBlock","getRootBlock","bringToFront","update","dxy","deleteArea","candidate","getCandidate_","shouldDelete_","shouldUpdate","shouldUpdatePreviews_","maybeHidePreview_","maybeShowPreview_","sourceBlock","imType","type","result","newBlock","setInsertionMarker","mutationToDom","oldMutationDom","domToMutation","i","sourceInput","inputList","name","Block","COLLAPSED_INPUT_NAME","resultInput","j","fieldRow","sourceField","resultField","setValue","getValue","setCollapsed","isCollapsed","setInputsInline","getInputsInline","initSvg","getSvgRoot","setAttribute","available","getConnections_","lastOnStack","lastConnectionInStack","nextConnection","push","candidateLocal","local","candidateClosest","closest","radius","xDiff","x","yDiff","y","curDistance","Math","sqrt","CURRENT_CONNECTION_PREFERENCE","console","error","getStartRadius_","myConnection","neighbour","connection","CONNECTING_SNAP_RADIUS","SNAP_RADIUS","wouldConnect","DELETE_AREA_TOOLBOX","wouldDelete","getParent","isDeletable","isInsertionMarker","log","showPreview_","renderer","getRenderer","method","getConnectionPreviewMethod","showInsertionInputOutline_","showInsertionMarker_","showReplacementFade_","shouldHighlightConnection","highlight","hadPreview","closestChanged","localChanged","targetBlock","unhighlight","hideReplacementFade_","hideInsertionInputOutline_","hideInsertionMarker_","isLastInStack","imBlock","imConn","getMatchingConnection","Error","render","positionNearConnection","markerNext","markerPrev","previousConnection","markerOutput","outputConnection","isFirstInStatementStack","targetConnection","isFirstInOutputStack","INPUT_VALUE","unplug","NEXT_STATEMENT","innerConnection","previousBlockNextConnection","highlightShapeForInput","fadeForReplacement","getInsertionMarkers"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Class that controls updates to connections during drags.\n * @author fenichel@google.com (Rachel Fenichel)\n */\n'use strict';\n\ngoog.provide('Blockly.InsertionMarkerManager');\n\ngoog.require('Blockly.blockAnimations');\ngoog.require('Blockly.Events');\n\n\n/**\n * Class that controls updates to connections during drags.  It is primarily\n * responsible for finding the closest eligible connection and highlighting or\n * unhiglighting it as needed during a drag.\n * @param {!Blockly.BlockSvg} block The top block in the stack being dragged.\n * @constructor\n */\nBlockly.InsertionMarkerManager = function(block) {\n  Blockly.selected = block;\n\n  /**\n   * The top block in the stack being dragged.\n   * Does not change during a drag.\n   * @type {!Blockly.BlockSvg}\n   * @private\n   */\n  this.topBlock_ = block;\n\n  /**\n   * The workspace on which these connections are being dragged.\n   * Does not change during a drag.\n   * @type {!Blockly.WorkspaceSvg}\n   * @private\n   */\n  this.workspace_ = block.workspace;\n\n  /**\n   * The last connection on the stack, if it's not the last connection on the\n   * first block.\n   * Set in initAvailableConnections, if at all.\n   * @type {Blockly.RenderedConnection}\n   * @private\n   */\n  this.lastOnStack_ = null;\n\n  /**\n   * The insertion marker corresponding to the last block in the stack, if\n   * that's not the same as the first block in the stack.\n   * Set in initAvailableConnections, if at all\n   * @type {Blockly.BlockSvg}\n   * @private\n   */\n  this.lastMarker_ = null;\n\n  /**\n   * The insertion marker that shows up between blocks to show where a block\n   * would go if dropped immediately.\n   * @type {Blockly.BlockSvg}\n   * @private\n   */\n  this.firstMarker_ = this.createMarkerBlock_(this.topBlock_);\n\n  /**\n   * The connection that this block would connect to if released immediately.\n   * Updated on every mouse move.\n   * This is not on any of the blocks that are being dragged.\n   * @type {Blockly.RenderedConnection}\n   * @private\n   */\n  this.closestConnection_ = null;\n\n  /**\n   * The connection that would connect to this.closestConnection_ if this block\n   * were released immediately.\n   * Updated on every mouse move.\n   * This is on the top block that is being dragged or the last block in the\n   * dragging stack.\n   * @type {Blockly.RenderedConnection}\n   * @private\n   */\n  this.localConnection_ = null;\n\n  /**\n   * Whether the block would be deleted if it were dropped immediately.\n   * Updated on every mouse move.\n   * @type {boolean}\n   * @private\n   */\n  this.wouldDeleteBlock_ = false;\n\n  /**\n   * Connection on the insertion marker block that corresponds to\n   * this.localConnection_ on the currently dragged block.\n   * @type {Blockly.RenderedConnection}\n   * @private\n   */\n  this.markerConnection_ = null;\n\n  /**\n   * The block that currently has an input being highlighted, or null.\n   * @type {Blockly.BlockSvg}\n   * @private\n   */\n  this.highlightedBlock_ = null;\n\n  /**\n   * The block being faded to indicate replacement, or null.\n   * @type {Blockly.BlockSvg}\n   * @private\n   */\n  this.fadedBlock_ = null;\n\n  /**\n   * The connections on the dragging blocks that are available to connect to\n   * other blocks.  This includes all open connections on the top block, as well\n   * as the last connection on the block stack.\n   * Does not change during a drag.\n   * @type {!Array.<!Blockly.RenderedConnection>}\n   * @private\n   */\n  this.availableConnections_ = this.initAvailableConnections_();\n};\n\n/**\n * An enum describing different kinds of previews the InsertionMarkerManager\n * could display.\n * @enum {number}\n */\nBlockly.InsertionMarkerManager.PREVIEW_TYPE = {\n  INSERTION_MARKER: 0,\n  INPUT_OUTLINE: 1,\n  REPLACEMENT_FADE: 2,\n};\n\n/**\n * Sever all links from this object.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.dispose = function() {\n  this.availableConnections_.length = 0;\n\n  Blockly.Events.disable();\n  try {\n    if (this.firstMarker_) {\n      this.firstMarker_.dispose();\n    }\n    if (this.lastMarker_) {\n      this.lastMarker_.dispose();\n    }\n  } finally {\n    Blockly.Events.enable();\n  }\n};\n\n/**\n * Update the available connections for the top block. These connections can\n * change if a block is unplugged and the stack is healed.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.updateAvailableConnections = function() {\n  this.availableConnections_ = this.initAvailableConnections_();\n};\n\n/**\n * Return whether the block would be deleted if dropped immediately, based on\n * information from the most recent move event.\n * @return {boolean} True if the block would be deleted if dropped immediately.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.wouldDeleteBlock = function() {\n  return this.wouldDeleteBlock_;\n};\n\n/**\n * Return whether the block would be connected if dropped immediately, based on\n * information from the most recent move event.\n * @return {boolean} True if the block would be connected if dropped\n *   immediately.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.wouldConnectBlock = function() {\n  return !!this.closestConnection_;\n};\n\n/**\n * Connect to the closest connection and render the results.\n * This should be called at the end of a drag.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.applyConnections = function() {\n  if (this.closestConnection_) {\n    // Don't fire events for insertion markers.\n    Blockly.Events.disable();\n    this.hidePreview_();\n    Blockly.Events.enable();\n    // Connect two blocks together.\n    this.localConnection_.connect(this.closestConnection_);\n    if (this.topBlock_.rendered) {\n      // Trigger a connection animation.\n      // Determine which connection is inferior (lower in the source stack).\n      var inferiorConnection = this.localConnection_.isSuperior() ?\n          this.closestConnection_ : this.localConnection_;\n      Blockly.blockAnimations.connectionUiEffect(\n          inferiorConnection.getSourceBlock());\n      // Bring the just-edited stack to the front.\n      var rootBlock = this.topBlock_.getRootBlock();\n      rootBlock.bringToFront();\n    }\n  }\n};\n\n/**\n * Update connections based on the most recent move location.\n * @param {!Blockly.utils.Coordinate} dxy Position relative to drag start,\n *     in workspace units.\n * @param {?number} deleteArea One of {@link Blockly.DELETE_AREA_TRASH},\n *     {@link Blockly.DELETE_AREA_TOOLBOX}, or {@link Blockly.DELETE_AREA_NONE}.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.update = function(dxy, deleteArea) {\n  var candidate = this.getCandidate_(dxy);\n\n  this.wouldDeleteBlock_ = this.shouldDelete_(candidate, deleteArea);\n  var shouldUpdate = this.wouldDeleteBlock_ ||\n      this.shouldUpdatePreviews_(candidate, dxy);\n\n  if (shouldUpdate) {\n    // Don't fire events for insertion marker creation or movement.\n    Blockly.Events.disable();\n    this.maybeHidePreview_(candidate);\n    this.maybeShowPreview_(candidate);\n    Blockly.Events.enable();\n  }\n};\n\n/**\n * Create an insertion marker that represents the given block.\n * @param {!Blockly.BlockSvg} sourceBlock The block that the insertion marker\n *     will represent.\n * @return {!Blockly.BlockSvg} The insertion marker that represents the given\n *     block.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.createMarkerBlock_ = function(sourceBlock) {\n  var imType = sourceBlock.type;\n\n  Blockly.Events.disable();\n  try {\n    var result = this.workspace_.newBlock(imType);\n    result.setInsertionMarker(true);\n    if (sourceBlock.mutationToDom) {\n      var oldMutationDom = sourceBlock.mutationToDom();\n      if (oldMutationDom) {\n        result.domToMutation(oldMutationDom);\n      }\n    }\n    // Copy field values from the other block.  These values may impact the\n    // rendered size of the insertion marker.  Note that we do not care about\n    // child blocks here.\n    for (var i = 0; i < sourceBlock.inputList.length; i++) {\n      var sourceInput = sourceBlock.inputList[i];\n      if (sourceInput.name == Blockly.Block.COLLAPSED_INPUT_NAME) {\n        continue;  // Ignore the collapsed input.\n      }\n      var resultInput = result.inputList[i];\n      for (var j = 0; j < sourceInput.fieldRow.length; j++) {\n        var sourceField = sourceInput.fieldRow[j];\n        var resultField = resultInput.fieldRow[j];\n        resultField.setValue(sourceField.getValue());\n      }\n    }\n\n    result.setCollapsed(sourceBlock.isCollapsed());\n    result.setInputsInline(sourceBlock.getInputsInline());\n\n    result.initSvg();\n    result.getSvgRoot().setAttribute('visibility', 'hidden');\n  } finally {\n    Blockly.Events.enable();\n  }\n\n  return result;\n};\n\n/**\n * Populate the list of available connections on this block stack.  This should\n * only be called once, at the beginning of a drag.\n * If the stack has more than one block, this function will populate\n * lastOnStack_ and create the corresponding insertion marker.\n * @return {!Array.<!Blockly.RenderedConnection>} A list of available\n *     connections.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.initAvailableConnections_ = function() {\n  var available = this.topBlock_.getConnections_(false);\n  // Also check the last connection on this stack\n  var lastOnStack = this.topBlock_.lastConnectionInStack();\n  if (lastOnStack && lastOnStack != this.topBlock_.nextConnection) {\n    available.push(lastOnStack);\n    this.lastOnStack_ = lastOnStack;\n    this.lastMarker_ = this.createMarkerBlock_(lastOnStack.getSourceBlock());\n  }\n  return available;\n};\n\n/**\n * Whether the previews (insertion marker and replacement marker) should be\n * updated based on the closest candidate and the current drag distance.\n * @param {!Object} candidate An object containing a local connection, a closest\n *     connection, and a radius.  Returned by getCandidate_.\n * @param {!Blockly.utils.Coordinate} dxy Position relative to drag start,\n *     in workspace units.\n * @return {boolean} Whether the preview should be updated.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.shouldUpdatePreviews_ = function(\n    candidate, dxy) {\n  var candidateLocal = candidate.local;\n  var candidateClosest = candidate.closest;\n  var radius = candidate.radius;\n\n  // Found a connection!\n  if (candidateLocal && candidateClosest) {\n    // We're already showing an insertion marker.\n    // Decide whether the new connection has higher priority.\n    if (this.localConnection_ && this.closestConnection_) {\n      // The connection was the same as the current connection.\n      if (this.closestConnection_ == candidateClosest &&\n          this.localConnection_ == candidateLocal) {\n        return false;\n      }\n      var xDiff = this.localConnection_.x + dxy.x - this.closestConnection_.x;\n      var yDiff = this.localConnection_.y + dxy.y - this.closestConnection_.y;\n      var curDistance = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n      // Slightly prefer the existing preview over a new preview.\n      return !(candidateClosest && radius > curDistance -\n          Blockly.CURRENT_CONNECTION_PREFERENCE);\n    } else if (!this.localConnection_ && !this.closestConnection_) {\n    // We weren't showing a preview before, but we should now.\n      return true;\n    } else {\n      console.error('Only one of localConnection_ and closestConnection_ was set.');\n    }\n  } else { // No connection found.\n    // Only need to update if we were showing a preview before.\n    return !!(this.localConnection_ && this.closestConnection_);\n  }\n\n  console.error('Returning true from shouldUpdatePreviews, but it\\'s not clear why.');\n  return true;\n};\n\n/**\n * Find the nearest valid connection, which may be the same as the current\n * closest connection.\n * @param {!Blockly.utils.Coordinate} dxy Position relative to drag start,\n *     in workspace units.\n * @return {!Object} An object containing a local connection, a closest\n *     connection, and a radius.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.getCandidate_ = function(dxy) {\n  var radius = this.getStartRadius_();\n  var candidateClosest = null;\n  var candidateLocal = null;\n\n  for (var i = 0; i < this.availableConnections_.length; i++) {\n    var myConnection = this.availableConnections_[i];\n    var neighbour = myConnection.closest(radius, dxy);\n    if (neighbour.connection) {\n      candidateClosest = neighbour.connection;\n      candidateLocal = myConnection;\n      radius = neighbour.radius;\n    }\n  }\n  return {\n    closest: candidateClosest,\n    local: candidateLocal,\n    radius: radius\n  };\n};\n\n/**\n * Decide the radius at which to start searching for the closest connection.\n * @return {number} The radius at which to start the search for the closest\n *     connection.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.getStartRadius_ = function() {\n  // If there is already a connection highlighted,\n  // increase the radius we check for making new connections.\n  // Why? When a connection is highlighted, blocks move around when the insertion\n  // marker is created, which could cause the connection became out of range.\n  // By increasing radiusConnection when a connection already exists,\n  // we never \"lose\" the connection from the offset.\n  if (this.closestConnection_ && this.localConnection_) {\n    return Blockly.CONNECTING_SNAP_RADIUS;\n  }\n  return Blockly.SNAP_RADIUS;\n};\n\n/**\n * Whether ending the drag would delete the block.\n * @param {!Object} candidate An object containing a local connection, a closest\n *     connection, and a radius.\n * @param {?number} deleteArea One of {@link Blockly.DELETE_AREA_TRASH},\n *     {@link Blockly.DELETE_AREA_TOOLBOX}, or {@link Blockly.DELETE_AREA_NONE}.\n * @return {boolean} True if dropping the block immediately would replace\n *     delete the block.  False otherwise.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.shouldDelete_ = function(candidate,\n    deleteArea) {\n  // Prefer connecting over dropping into the trash can, but prefer dragging to\n  // the toolbox over connecting to other blocks.\n  var wouldConnect = candidate && !!candidate.closest &&\n      deleteArea != Blockly.DELETE_AREA_TOOLBOX;\n  var wouldDelete = !!deleteArea && !this.topBlock_.getParent() &&\n      this.topBlock_.isDeletable();\n\n  return wouldDelete && !wouldConnect;\n};\n\n/**\n * Show an insertion marker or replacement highlighting during a drag, if\n * needed.\n * At the beginning of this function, this.localConnection_ and\n * this.closestConnection_ should both be null.\n * @param {!Object} candidate An object containing a local connection, a closest\n *     connection, and a radius.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.maybeShowPreview_ = function(candidate) {\n  // Nope, don't add a marker.\n  if (this.wouldDeleteBlock_) {\n    return;\n  }\n  var closest = candidate.closest;\n  var local = candidate.local;\n\n  // Nothing to connect to.\n  if (!closest) {\n    return;\n  }\n\n  // Something went wrong and we're trying to connect to an invalid connection.\n  if (closest == this.closestConnection_ ||\n      closest.getSourceBlock().isInsertionMarker()) {\n    console.log('Trying to connect to an insertion marker');\n    return;\n  }\n  // Add an insertion marker or replacement marker.\n  this.closestConnection_ = closest;\n  this.localConnection_ = local;\n  this.showPreview_();\n};\n\n/**\n * A preview should be shown.  This function figures out if it should be a block\n * highlight or an insertion marker, and shows the appropriate one.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.showPreview_ = function() {\n  var closest = this.closestConnection_;\n  var renderer = this.workspace_.getRenderer();\n  var method = renderer.getConnectionPreviewMethod(\n      /** @type {!Blockly.RenderedConnection} */ (closest),\n      /** @type {!Blockly.RenderedConnection} */ (this.localConnection_),\n      this.topBlock_);\n\n  switch (method) {\n    case Blockly.InsertionMarkerManager.PREVIEW_TYPE.INPUT_OUTLINE:\n      this.showInsertionInputOutline_();\n      break;\n    case Blockly.InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER:\n      this.showInsertionMarker_();\n      break;\n    case Blockly.InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE:\n      this.showReplacementFade_();\n      break;\n  }\n\n  // Optionally highlight the actual connection, as a nod to previous behaviour.\n  if (closest && renderer.shouldHighlightConnection(closest)) {\n    closest.highlight();\n  }\n};\n\n/**\n * Show an insertion marker or replacement highlighting during a drag, if\n * needed.\n * At the end of this function, this.localConnection_ and\n * this.closestConnection_ should both be null.\n * @param {!Object} candidate An object containing a local connection, a closest\n *     connection, and a radius.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.maybeHidePreview_ = function(candidate) {\n  // If there's no new preview, remove the old one but don't bother deleting it.\n  // We might need it later, and this saves disposing of it and recreating it.\n  if (!candidate.closest) {\n    this.hidePreview_();\n  } else {\n    // If there's a new preview and there was an preview before, and either\n    // connection has changed, remove the old preview.\n    var hadPreview = this.closestConnection_ && this.localConnection_;\n    var closestChanged = this.closestConnection_ != candidate.closest;\n    var localChanged = this.localConnection_ != candidate.local;\n\n    // Also hide if we had a preview before but now we're going to delete instead.\n    if (hadPreview && (closestChanged || localChanged || this.wouldDeleteBlock_)) {\n      this.hidePreview_();\n    }\n  }\n\n  // Either way, clear out old state.\n  this.markerConnection_ = null;\n  this.closestConnection_ = null;\n  this.localConnection_ = null;\n};\n\n/**\n * A preview should be hidden.  This function figures out if it is a block\n *  highlight or an insertion marker, and hides the appropriate one.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.hidePreview_ = function() {\n  if (this.closestConnection_ && this.closestConnection_.targetBlock() &&\n      this.workspace_.getRenderer()\n          .shouldHighlightConnection(this.closestConnection_)) {\n    this.closestConnection_.unhighlight();\n  }\n  if (this.fadedBlock_) {\n    this.hideReplacementFade_();\n  } else if (this.highlightedBlock_) {\n    this.hideInsertionInputOutline_();\n  } else if (this.markerConnection_) {\n    this.hideInsertionMarker_();\n  }\n};\n\n/**\n * Shows an insertion marker connected to the appropriate blocks (based on\n * manager state).\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.showInsertionMarker_ = function() {\n  var local = this.localConnection_;\n  var closest = this.closestConnection_;\n\n  var isLastInStack = this.lastOnStack_ && local == this.lastOnStack_;\n  var imBlock = isLastInStack ? this.lastMarker_ : this.firstMarker_;\n  var imConn = imBlock.getMatchingConnection(local.getSourceBlock(), local);\n\n  if (imConn == this.markerConnection_) {\n    throw Error('Made it to showInsertionMarker_ even though the marker isn\\'t ' +\n        'changing');\n  }\n\n  // Render disconnected from everything else so that we have a valid\n  // connection location.\n  imBlock.render();\n  imBlock.rendered = true;\n  imBlock.getSvgRoot().setAttribute('visibility', 'visible');\n\n  if (imConn && closest) {\n    // Position so that the existing block doesn't move.\n    imBlock.positionNearConnection(imConn, closest);\n  }\n  if (closest) {\n    // Connect() also renders the insertion marker.\n    imConn.connect(closest);\n  }\n\n  this.markerConnection_ = imConn;\n};\n\n/**\n * Disconnects and hides the current insertion marker. Should return the blocks\n * to their original state.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.hideInsertionMarker_ = function() {\n  if (!this.markerConnection_) {\n    console.log('No insertion marker connection to disconnect');\n    return;\n  }\n\n  var imConn = this.markerConnection_;\n  var imBlock = imConn.getSourceBlock();\n  var markerNext = imBlock.nextConnection;\n  var markerPrev = imBlock.previousConnection;\n  var markerOutput = imBlock.outputConnection;\n\n  var isFirstInStatementStack =\n      (imConn == markerNext && !(markerPrev && markerPrev.targetConnection));\n\n  var isFirstInOutputStack = imConn.type == Blockly.INPUT_VALUE &&\n      !(markerOutput && markerOutput.targetConnection);\n  // The insertion marker is the first block in a stack.  Unplug won't do\n  // anything in that case.  Instead, unplug the following block.\n  if (isFirstInStatementStack || isFirstInOutputStack) {\n    imConn.targetBlock().unplug(false);\n  }\n  // Inside of a C-block, first statement connection.\n  else if (imConn.type == Blockly.NEXT_STATEMENT && imConn != markerNext) {\n    var innerConnection = imConn.targetConnection;\n    innerConnection.getSourceBlock().unplug(false);\n\n    var previousBlockNextConnection =\n        markerPrev ? markerPrev.targetConnection : null;\n\n    imBlock.unplug(true);\n    if (previousBlockNextConnection) {\n      previousBlockNextConnection.connect(innerConnection);\n    }\n  } else {\n    imBlock.unplug(true /* healStack */);\n  }\n\n  if (imConn.targetConnection) {\n    throw Error('markerConnection_ still connected at the end of ' +\n        'disconnectInsertionMarker');\n  }\n\n  this.markerConnection_ = null;\n  imBlock.getSvgRoot().setAttribute('visibility', 'hidden');\n};\n\n/**\n * Shows an outline around the input the closest connection belongs to.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.showInsertionInputOutline_ = function() {\n  var closest = this.closestConnection_;\n  this.highlightedBlock_ = closest.getSourceBlock();\n  this.highlightedBlock_.highlightShapeForInput(closest, true);\n};\n\n/**\n * Hides any visible input outlines.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.hideInsertionInputOutline_ = function() {\n  this.highlightedBlock_.highlightShapeForInput(this.closestConnection_, false);\n  this.highlightedBlock_ = null;\n};\n\n/**\n * Shows a replacement fade affect on the closest connection's target block\n * (the block that is currently connected to it).\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.showReplacementFade_ = function() {\n  this.fadedBlock_ = this.closestConnection_.targetBlock();\n  this.fadedBlock_.fadeForReplacement(true);\n};\n\n/**\n * Hides/Removes any visible fade affects.\n * @private\n */\nBlockly.InsertionMarkerManager.prototype.hideReplacementFade_ = function() {\n  this.fadedBlock_.fadeForReplacement(false);\n  this.fadedBlock_ = null;\n};\n\n/**\n * Get a list of the insertion markers that currently exist.  Drags have 0, 1,\n * or 2 insertion markers.\n * @return {!Array.<!Blockly.BlockSvg>} A possibly empty list of insertion\n *     marker blocks.\n * @package\n */\nBlockly.InsertionMarkerManager.prototype.getInsertionMarkers = function() {\n  var result = [];\n  if (this.firstMarker_) {\n    result.push(this.firstMarker_);\n  }\n  if (this.lastMarker_) {\n    result.push(this.lastMarker_);\n  }\n  return result;\n};\n"],"file":"insertion_marker_manager.min.js"}