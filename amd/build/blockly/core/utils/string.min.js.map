{"version":3,"sources":["../../../../src/blockly/core/utils/string.js"],"names":["goog","provide","Blockly","utils","string","startsWith","str","prefix","lastIndexOf","shortestStringLength","array","length","reduce","a","b","commonWordPrefix","opt_shortest","wordPrefix","max","len","letter","i","commonWordSuffix","substr","charAt","wrap","text","limit","lines","split","wrapLine_","join","words","trim","lastScore","score","Infinity","lastText","lineCount","wordBreaks","steps","insertedBreaks","wrapMutate_","wrapScore_","wrapToText_","lineLengths","linePunctuation","push","maxLength","Math","apply","pow","abs","indexOf","bestScore","bestBreaks","mutatedWordBreaks","concat","mutatedScore"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility methods for string manipulation.\n * These methods are not specific to Blockly, and could be factored out into\n * a JavaScript framework such as Closure.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\n/**\n * @name Blockly.utils.string\n * @namespace\n */\ngoog.provide('Blockly.utils.string');\n\n\n/**\n * Fast prefix-checker.\n * Copied from Closure's goog.string.startsWith.\n * @param {string} str The string to check.\n * @param {string} prefix A string to look for at the start of `str`.\n * @return {boolean} True if `str` begins with `prefix`.\n */\nBlockly.utils.string.startsWith = function(str, prefix) {\n  return str.lastIndexOf(prefix, 0) == 0;\n};\n\n/**\n * Given an array of strings, return the length of the shortest one.\n * @param {!Array.<string>} array Array of strings.\n * @return {number} Length of shortest string.\n */\nBlockly.utils.string.shortestStringLength = function(array) {\n  if (!array.length) {\n    return 0;\n  }\n  return array.reduce(function(a, b) {\n    return a.length < b.length ? a : b;\n  }).length;\n};\n\n/**\n * Given an array of strings, return the length of the common prefix.\n * Words may not be split.  Any space after a word is included in the length.\n * @param {!Array.<string>} array Array of strings.\n * @param {number=} opt_shortest Length of shortest string.\n * @return {number} Length of common prefix.\n */\nBlockly.utils.string.commonWordPrefix = function(array, opt_shortest) {\n  if (!array.length) {\n    return 0;\n  } else if (array.length == 1) {\n    return array[0].length;\n  }\n  var wordPrefix = 0;\n  var max = opt_shortest || Blockly.utils.string.shortestStringLength(array);\n  for (var len = 0; len < max; len++) {\n    var letter = array[0][len];\n    for (var i = 1; i < array.length; i++) {\n      if (letter != array[i][len]) {\n        return wordPrefix;\n      }\n    }\n    if (letter == ' ') {\n      wordPrefix = len + 1;\n    }\n  }\n  for (var i = 1; i < array.length; i++) {\n    var letter = array[i][len];\n    if (letter && letter != ' ') {\n      return wordPrefix;\n    }\n  }\n  return max;\n};\n\n/**\n * Given an array of strings, return the length of the common suffix.\n * Words may not be split.  Any space after a word is included in the length.\n * @param {!Array.<string>} array Array of strings.\n * @param {number=} opt_shortest Length of shortest string.\n * @return {number} Length of common suffix.\n */\nBlockly.utils.string.commonWordSuffix = function(array, opt_shortest) {\n  if (!array.length) {\n    return 0;\n  } else if (array.length == 1) {\n    return array[0].length;\n  }\n  var wordPrefix = 0;\n  var max = opt_shortest || Blockly.utils.string.shortestStringLength(array);\n  for (var len = 0; len < max; len++) {\n    var letter = array[0].substr(-len - 1, 1);\n    for (var i = 1; i < array.length; i++) {\n      if (letter != array[i].substr(-len - 1, 1)) {\n        return wordPrefix;\n      }\n    }\n    if (letter == ' ') {\n      wordPrefix = len + 1;\n    }\n  }\n  for (var i = 1; i < array.length; i++) {\n    var letter = array[i].charAt(array[i].length - len - 1);\n    if (letter && letter != ' ') {\n      return wordPrefix;\n    }\n  }\n  return max;\n};\n\n/**\n * Wrap text to the specified width.\n * @param {string} text Text to wrap.\n * @param {number} limit Width to wrap each line.\n * @return {string} Wrapped text.\n */\nBlockly.utils.string.wrap = function(text, limit) {\n  var lines = text.split('\\n');\n  for (var i = 0; i < lines.length; i++) {\n    lines[i] = Blockly.utils.string.wrapLine_(lines[i], limit);\n  }\n  return lines.join('\\n');\n};\n\n/**\n * Wrap single line of text to the specified width.\n * @param {string} text Text to wrap.\n * @param {number} limit Width to wrap each line.\n * @return {string} Wrapped text.\n * @private\n */\nBlockly.utils.string.wrapLine_ = function(text, limit) {\n  if (text.length <= limit) {\n    // Short text, no need to wrap.\n    return text;\n  }\n  // Split the text into words.\n  var words = text.trim().split(/\\s+/);\n  // Set limit to be the length of the largest word.\n  for (var i = 0; i < words.length; i++) {\n    if (words[i].length > limit) {\n      limit = words[i].length;\n    }\n  }\n\n  var lastScore;\n  var score = -Infinity;\n  var lastText;\n  var lineCount = 1;\n  do {\n    lastScore = score;\n    lastText = text;\n    // Create a list of booleans representing if a space (false) or\n    // a break (true) appears after each word.\n    var wordBreaks = [];\n    // Seed the list with evenly spaced linebreaks.\n    var steps = words.length / lineCount;\n    var insertedBreaks = 1;\n    for (var i = 0; i < words.length - 1; i++) {\n      if (insertedBreaks < (i + 1.5) / steps) {\n        insertedBreaks++;\n        wordBreaks[i] = true;\n      } else {\n        wordBreaks[i] = false;\n      }\n    }\n    wordBreaks = Blockly.utils.string.wrapMutate_(words, wordBreaks, limit);\n    score = Blockly.utils.string.wrapScore_(words, wordBreaks, limit);\n    text = Blockly.utils.string.wrapToText_(words, wordBreaks);\n    lineCount++;\n  } while (score > lastScore);\n  return lastText;\n};\n\n/**\n * Compute a score for how good the wrapping is.\n * @param {!Array.<string>} words Array of each word.\n * @param {!Array.<boolean>} wordBreaks Array of line breaks.\n * @param {number} limit Width to wrap each line.\n * @return {number} Larger the better.\n * @private\n */\nBlockly.utils.string.wrapScore_ = function(words, wordBreaks, limit) {\n  // If this function becomes a performance liability, add caching.\n  // Compute the length of each line.\n  var lineLengths = [0];\n  var linePunctuation = [];\n  for (var i = 0; i < words.length; i++) {\n    lineLengths[lineLengths.length - 1] += words[i].length;\n    if (wordBreaks[i] === true) {\n      lineLengths.push(0);\n      linePunctuation.push(words[i].charAt(words[i].length - 1));\n    } else if (wordBreaks[i] === false) {\n      lineLengths[lineLengths.length - 1]++;\n    }\n  }\n  var maxLength = Math.max.apply(Math, lineLengths);\n\n  var score = 0;\n  for (var i = 0; i < lineLengths.length; i++) {\n    // Optimize for width.\n    // -2 points per char over limit (scaled to the power of 1.5).\n    score -= Math.pow(Math.abs(limit - lineLengths[i]), 1.5) * 2;\n    // Optimize for even lines.\n    // -1 point per char smaller than max (scaled to the power of 1.5).\n    score -= Math.pow(maxLength - lineLengths[i], 1.5);\n    // Optimize for structure.\n    // Add score to line endings after punctuation.\n    if ('.?!'.indexOf(linePunctuation[i]) != -1) {\n      score += limit / 3;\n    } else if (',;)]}'.indexOf(linePunctuation[i]) != -1) {\n      score += limit / 4;\n    }\n  }\n  // All else being equal, the last line should not be longer than the\n  // previous line.  For example, this looks wrong:\n  // aaa bbb\n  // ccc ddd eee\n  if (lineLengths.length > 1 && lineLengths[lineLengths.length - 1] <=\n      lineLengths[lineLengths.length - 2]) {\n    score += 0.5;\n  }\n  return score;\n};\n\n/**\n * Mutate the array of line break locations until an optimal solution is found.\n * No line breaks are added or deleted, they are simply moved around.\n * @param {!Array.<string>} words Array of each word.\n * @param {!Array.<boolean>} wordBreaks Array of line breaks.\n * @param {number} limit Width to wrap each line.\n * @return {!Array.<boolean>} New array of optimal line breaks.\n * @private\n */\nBlockly.utils.string.wrapMutate_ = function(words, wordBreaks, limit) {\n  var bestScore = Blockly.utils.string.wrapScore_(words, wordBreaks, limit);\n  var bestBreaks;\n  // Try shifting every line break forward or backward.\n  for (var i = 0; i < wordBreaks.length - 1; i++) {\n    if (wordBreaks[i] == wordBreaks[i + 1]) {\n      continue;\n    }\n    var mutatedWordBreaks = [].concat(wordBreaks);\n    mutatedWordBreaks[i] = !mutatedWordBreaks[i];\n    mutatedWordBreaks[i + 1] = !mutatedWordBreaks[i + 1];\n    var mutatedScore =\n        Blockly.utils.string.wrapScore_(words, mutatedWordBreaks, limit);\n    if (mutatedScore > bestScore) {\n      bestScore = mutatedScore;\n      bestBreaks = mutatedWordBreaks;\n    }\n  }\n  if (bestBreaks) {\n    // Found an improvement.  See if it may be improved further.\n    return Blockly.utils.string.wrapMutate_(words, bestBreaks, limit);\n  }\n  // No improvements found.  Done.\n  return wordBreaks;\n};\n\n/**\n * Reassemble the array of words into text, with the specified line breaks.\n * @param {!Array.<string>} words Array of each word.\n * @param {!Array.<boolean>} wordBreaks Array of line breaks.\n * @return {string} Plain text.\n * @private\n */\nBlockly.utils.string.wrapToText_ = function(words, wordBreaks) {\n  var text = [];\n  for (var i = 0; i < words.length; i++) {\n    text.push(words[i]);\n    if (wordBreaks[i] !== undefined) {\n      text.push(wordBreaks[i] ? '\\n' : ' ');\n    }\n  }\n  return text.join('');\n};\n\n"],"file":"string.min.js"}