{"version":3,"sources":["../../../src/blockly/core/names.js"],"names":["goog","provide","require","Blockly","Names","reservedWords","opt_variablePrefix","variablePrefix_","reservedDict_","Object","create","splitWords","split","i","length","reset","DEVELOPER_VARIABLE_TYPE","prototype","db_","dbReverse_","variableMap_","setVariableMap","map","getNameForUserVariable_","id","console","log","variable","getVariableById","name","getName","type","VARIABLE_CATEGORY_NAME","varName","normalized","toLowerCase","isVarType","prefix","safeName","getDistinctName","substr","safeName_","Msg","encodeURI","replace","indexOf","equals","name1","name2"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2012 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Utility functions for handling variables and procedure names.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\ngoog.provide('Blockly.Names');\n\ngoog.require('Blockly.Msg');\n\n\n/**\n * Class for a database of entity names (variables, functions, etc).\n * @param {string} reservedWords A comma-separated string of words that are\n *     illegal for use as names in a language (e.g. 'new,if,this,...').\n * @param {string=} opt_variablePrefix Some languages need a '$' or a namespace\n *     before all variable names.\n * @constructor\n */\nBlockly.Names = function(reservedWords, opt_variablePrefix) {\n  this.variablePrefix_ = opt_variablePrefix || '';\n  this.reservedDict_ = Object.create(null);\n  if (reservedWords) {\n    var splitWords = reservedWords.split(',');\n    for (var i = 0; i < splitWords.length; i++) {\n      this.reservedDict_[splitWords[i]] = true;\n    }\n  }\n  this.reset();\n};\n\n/**\n * Constant to separate developer variable names from user-defined variable\n * names when running generators.\n * A developer variable will be declared as a global in the generated code, but\n * will never be shown to the user in the workspace or stored in the variable\n * map.\n */\nBlockly.Names.DEVELOPER_VARIABLE_TYPE = 'DEVELOPER_VARIABLE';\n\n/**\n * When JavaScript (or most other languages) is generated, variable 'foo' and\n * procedure 'foo' would collide.  However, Blockly has no such problems since\n * variable get 'foo' and procedure call 'foo' are unambiguous.\n * Therefore, Blockly keeps a separate type name to disambiguate.\n * getName('foo', 'variable') -> 'foo'\n * getName('foo', 'procedure') -> 'foo2'\n */\n\n/**\n * Empty the database and start from scratch.  The reserved words are kept.\n */\nBlockly.Names.prototype.reset = function() {\n  this.db_ = Object.create(null);\n  this.dbReverse_ = Object.create(null);\n  this.variableMap_ = null;\n};\n\n/**\n * Set the variable map that maps from variable name to variable object.\n * @param {!Blockly.VariableMap} map The map to track.\n */\nBlockly.Names.prototype.setVariableMap = function(map) {\n  this.variableMap_ = map;\n};\n\n/**\n * Get the name for a user-defined variable, based on its ID.\n * This should only be used for variables of type\n * Blockly.VARIABLE_CATEGORY_NAME.\n * @param {string} id The ID to look up in the variable map.\n * @return {?string} The name of the referenced variable, or null if there was\n *     no variable map or the variable was not found in the map.\n * @private\n */\nBlockly.Names.prototype.getNameForUserVariable_ = function(id) {\n  if (!this.variableMap_) {\n    console.log('Deprecated call to Blockly.Names.prototype.getName without ' +\n        'defining a variable map. To fix, add the following code in your ' +\n        'generator\\'s init() function:\\n' +\n        'Blockly.YourGeneratorName.variableDB_.setVariableMap(' +\n        'workspace.getVariableMap());');\n    return null;\n  }\n  var variable = this.variableMap_.getVariableById(id);\n  if (variable) {\n    return variable.name;\n  } else {\n    return null;\n  }\n};\n\n/**\n * Convert a Blockly entity name to a legal exportable entity name.\n * @param {string} name The Blockly entity name (no constraints).\n * @param {string} type The type of entity in Blockly\n *     ('VARIABLE', 'PROCEDURE', 'BUILTIN', etc...).\n * @return {string} An entity name that is legal in the exported language.\n */\nBlockly.Names.prototype.getName = function(name, type) {\n  if (type == Blockly.VARIABLE_CATEGORY_NAME) {\n    var varName = this.getNameForUserVariable_(name);\n    if (varName) {\n      name = varName;\n    }\n  }\n  var normalized = name.toLowerCase() + '_' + type;\n\n  var isVarType = type == Blockly.VARIABLE_CATEGORY_NAME ||\n      type == Blockly.Names.DEVELOPER_VARIABLE_TYPE;\n\n  var prefix = isVarType ? this.variablePrefix_ : '';\n  if (normalized in this.db_) {\n    return prefix + this.db_[normalized];\n  }\n  var safeName = this.getDistinctName(name, type);\n  this.db_[normalized] = safeName.substr(prefix.length);\n  return safeName;\n};\n\n/**\n * Convert a Blockly entity name to a legal exportable entity name.\n * Ensure that this is a new name not overlapping any previously defined name.\n * Also check against list of reserved words for the current language and\n * ensure name doesn't collide.\n * @param {string} name The Blockly entity name (no constraints).\n * @param {string} type The type of entity in Blockly\n *     ('VARIABLE', 'PROCEDURE', 'BUILTIN', etc...).\n * @return {string} An entity name that is legal in the exported language.\n */\nBlockly.Names.prototype.getDistinctName = function(name, type) {\n  var safeName = this.safeName_(name);\n  var i = '';\n  while (this.dbReverse_[safeName + i] ||\n         (safeName + i) in this.reservedDict_) {\n    // Collision with existing name.  Create a unique name.\n    i = i ? i + 1 : 2;\n  }\n  safeName += i;\n  this.dbReverse_[safeName] = true;\n  var isVarType = type == Blockly.VARIABLE_CATEGORY_NAME ||\n      type == Blockly.Names.DEVELOPER_VARIABLE_TYPE;\n  var prefix = isVarType ? this.variablePrefix_ : '';\n  return prefix + safeName;\n};\n\n/**\n * Given a proposed entity name, generate a name that conforms to the\n * [_A-Za-z][_A-Za-z0-9]* format that most languages consider legal for\n * variables.\n * @param {string} name Potentially illegal entity name.\n * @return {string} Safe entity name.\n * @private\n */\nBlockly.Names.prototype.safeName_ = function(name) {\n  if (!name) {\n    name = Blockly.Msg['UNNAMED_KEY'] || 'unnamed';\n  } else {\n    // Unfortunately names in non-latin characters will look like\n    // _E9_9F_B3_E4_B9_90 which is pretty meaningless.\n    // https://github.com/google/blockly/issues/1654\n    name = encodeURI(name.replace(/ /g, '_')).replace(/[^\\w]/g, '_');\n    // Most languages don't allow names with leading numbers.\n    if ('0123456789'.indexOf(name[0]) != -1) {\n      name = 'my_' + name;\n    }\n  }\n  return name;\n};\n\n/**\n * Do the given two entity names refer to the same entity?\n * Blockly names are case-insensitive.\n * @param {string} name1 First name.\n * @param {string} name2 Second name.\n * @return {boolean} True if names are the same.\n */\nBlockly.Names.equals = function(name1, name2) {\n  return name1.toLowerCase() == name2.toLowerCase();\n};\n"],"file":"names.min.js"}