<?php
// This file is part of CodeRunner - http://coderunner.org.nz/
//
// CodeRunner is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CodeRunner is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CodeRunner.  If not, see <http://www.gnu.org/licenses/>.
/** The base class for the coderunner Grader classes.
 *  A Grader is called after running all testcases in a sandbox.
 *  Graders have an external name, which appears in the exported .xml question
 *  files for example, and a classname and a filename in which the class is
 *  defined.
 *  to confirm the correctness of the results.
 *  In the simplest subclass, qtype_coderunner_equality_grader, a test result is correct if
 *  the actual and expected outputs are identical after trailing white space
 *  has been removed. More complicated subclasses can, for example, do
 *  things like regular expression testing.
 */

/**
 * @package    qtype
 * @subpackage coderunner
 * @copyright  Richard Lobb, 2012, The University of Canterbury
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

require_once($CFG->dirroot . '/question/type/coderunner/testingoutcome.php');

abstract class qtype_coderunner_grader {
    /** Check all outputs, returning an array of TestResult objects.
     * A TestResult is an object with expected, got, isCorrect and grade fields.
     * 'got' and 'expected' fields are sanitised by replacing embedded
     * control characters with hex equivalents and by limiting their
     * lengths to MAX_STRING_LENGTH.
     */

    const MAX_STRING_LENGTH = 8000;

    // Return the name of this grader - one of available_graders() below.
    abstract public function name();

    /**
     * A list of available graders. Keys are the externally known grader names
     * as they appear in the exported questions, values are the associated
     * class names. File names are the same as the class names with the
     * leading qtype_coderunner and all underscores removed.
     * @return array
     */
    static public function available_graders() {
        return array('EqualityGrader'       => 'qtype_coderunner_equality_grader',
                     'NearEqualityGrader'   => 'qtype_coderunner_near_equality_grader',
                     'RegexGrader'          => 'qtype_coderunner_regex_grader',
                     'TemplateGrader'       => 'qtype_coderunner_template_grader',
                     'CombinatorTemplateGrader' => 'qtype_coderunner_combinator_template_grader'
                );
    }


    /**
     * Get the filename containing the given external grader name
     * @param string $externalgradername
     * @return string $filename
     */
    public static function get_filename($extgradername) {
        $graders = self::available_graders();
        $classname = $graders[$extgradername];
        return str_replace('_', '', str_replace('qtype_coderunner_', '', $classname)) . '.php';
    }


    /** Called to grade the output generated by a student's code for
     *  a given testcase. Returns a single TestResult object, which
     *  must have called tidy on the expected, output and stdin fields
     *  to limit their lengths.
     */
    public function grade(&$output, &$testcase, $isbad = false) {
        if ($isbad) {
            $outcome = new qtype_coderunner_test_result(
                        self::tidy($testcase->testcode),
                        $testcase->mark,
                        false,
                        0.0,
                        self::tidy($testcase->expected),
                        self::tidy($output),
                        self::tidy($testcase->stdin),
                        self::tidy($testcase->extra)
                    );
        } else {
            $outcome = $this->grade_known_good($output, $testcase);
        }
        return $outcome;
    }


    abstract protected function grade_known_good(&$output, &$testcase);

    // Return a cleaned and snipped version of the string s (or null if s is null).
    protected static function tidy($s) {
        if ($s === null) {
            return null;
        } else {
            $cleaneds = self::clean($s);
            return self::snip($cleaneds);
        }
    }

    protected static function clean(&$s) {
        // A copy of $s with trailing blank lines removed and trailing white
        // space from each line removed. Also sanitised by replacing all control
        // chars except newlines with hex equivalents.
        // A newline terminator is added at the end unless the string to be
        // returned is otherwise empty.
        // Used e.g. by the equality grader subclass.
        // This implementation is a bit algorithmically complex because the
        // original implemention, breaking the string into lines using explode,
        // was a hideous memory hog.
        $nls = '';     // Unused line breaks.
        $output = '';  // Output string.
        $spaces = '';  // Unused space characters.
        $n = strlen($s);
        for ($i = 0; $i < $n; $i++) {
            $c = $s[$i];
            if ($c === ' ') {
                $spaces .= $c;
            } else if ($c === "\n") {
                $spaces = ''; // Discard spaces before a newline.
                $nls .= $c;
            } else {
                if ($c === "\r") {
                    $c = '\\r';
                } else if ($c === "\t") {
                    $c = '\\t';
                } else if ($c < " " || $c > "\x7E") {
                    $c = '\\x' . sprintf("%02x", ord($c));
                }
                $output .= $nls . $spaces . $c;
                $spaces = '';
                $nls = '';
            }
        }
        if ($output !== '') {
            $output .= "\n";
        }
        return $output;
    }


    protected static function snip(&$s) {
        // Limit the length of the given string to MAX_STRING_LENGTH by
        // removing the centre of the string, inserting the substring
        // [... snip ... ] in its place.
        $snipinsert = ' ...snip... ';
        $len = strlen($s);
        if ($len > self::MAX_STRING_LENGTH) {
            $lentoremove = $len - self::MAX_STRING_LENGTH + strlen($snipinsert);
            $partlength = ($len - $lentoremove) / 2;
            $firstbit = substr($s, 0, $partlength);
            $lastbit = substr($s, $len - $partlength, $partlength);
            $s = $firstbit . $snipinsert . $lastbit;
        }
        return $s;
    }
}